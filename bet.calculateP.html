

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>bet.calculateP package &mdash; BET 1.0.0 documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic|Roboto+Slab:400,700|Inconsolata:400,700&subset=latin,cyrillic' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="BET 1.0.0 documentation" href="index.html"/>
        <link rel="up" title="bet package" href="bet.html"/>
        <link rel="next" title="bet.postProcess package" href="bet.postProcess.html"/>
        <link rel="prev" title="bet package" href="bet.html"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        
          <a href="index.html" class="fa fa-home"> BET</a>
        
        
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
          
          
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="overview.html">Overview</a><ul>
<li class="toctree-l2"><a class="reference internal" href="overview.html#installation">Installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="overview.html#package-layout">Package Layout</a></li>
<li class="toctree-l2"><a class="reference internal" href="overview.html#code-overview">Code Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="overview.html#internal-dependencies">Internal dependencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="overview.html#external-dependencies">External dependencies</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="parallel.html">Parallel</a><ul>
<li class="toctree-l2"><a class="reference internal" href="parallel.html#installation">Installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel.html#running-in-parallel">Running in parallel</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel.html#parallel-enabled-modules">Parallel Enabled Modules</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="examples/overview.html">Some References and Examples</a><ul>
<li class="toctree-l2"><a class="reference internal" href="examples/overview.html#validation-example">Validation example</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples/overview.html#linear-map-example">Linear Map Example</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples/overview.html#non-linear-map-example">Non-Linear Map Example</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples/overview.html#adcirc-based-examples">ADCIRC Based Examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples/overview.html#contaminant-transport-example">Contaminant Transport Example:</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples/overview.html#choosing-optimal-qois-example">Choosing Optimal QoIs Example:</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="modules.html">bet</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="bet.html">bet package</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="todo_list.html">Todo List</a></li>
</ul>

          
        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">BET</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
          <li><a href="modules.html">bet</a> &raquo;</li>
      
          <li><a href="bet.html">bet package</a> &raquo;</li>
      
    <li>bet.calculateP package</li>
      <li class="wy-breadcrumbs-aside">
        
          <a href="_sources/bet.calculateP.txt" rel="nofollow"> View page source</a>
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <div class="section" id="bet-calculatep-package">
<h1>bet.calculateP package<a class="headerlink" href="#bet-calculatep-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-bet.calculateP.calculateP">
<span id="bet-calculatep-calculatep-module"></span><h2>bet.calculateP.calculateP module<a class="headerlink" href="#module-bet.calculateP.calculateP" title="Permalink to this headline">¶</a></h2>
<p>This module provides methods for calulating the probability measure
<span class="math">\(P_{\Lambda}\)</span>.</p>
<ul>
<li><dl class="first docutils">
<dt><code class="xref py py-mod docutils literal"><span class="pre">prob_emulated</span></code> provides a skeleton class and calculates</dt>
<dd><p class="first last">the probability for a set of emulation points.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="xref py py-mod docutils literal"><span class="pre">prob_samples_mc</span></code> estimates the volumes of</dt>
<dd><p class="first last">the voronoi cells using MC integration</p>
</dd>
</dl>
</li>
</ul>
<dl class="function">
<dt id="bet.calculateP.calculateP.emulate_iid_lebesgue">
<code class="descclassname">bet.calculateP.calculateP.</code><code class="descname">emulate_iid_lebesgue</code><span class="sig-paren">(</span><em>lam_domain</em>, <em>num_l_emulate</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.calculateP.emulate_iid_lebesgue" title="Permalink to this definition">¶</a></dt>
<dd><p>Parition the parameter space using emulated samples into many voronoi
cells. These samples are iid so that we can apply the standard MC                                       
assumuption/approximation</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lam_domain</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of shape (ndim, 2)) &#8211; The domain for each parameter for the model.</li>
<li><strong>num_l_emulate</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; The number of emulated samples.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of shape (num_l_emulate, ndim)</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a set of samples for emulation</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.calculateP.calculateP.prob">
<code class="descclassname">bet.calculateP.calculateP.</code><code class="descname">prob</code><span class="sig-paren">(</span><em>samples</em>, <em>data</em>, <em>rho_D_M</em>, <em>d_distr_samples</em>, <em>d_Tree=None</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.calculateP.prob" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <span class="math">\(P_{\Lambda}(\mathcal{V}_{\lambda_{samples}})\)</span>, the
probability assoicated with a set of voronoi cells defined by the model
solves at <span class="math">\((\lambda_{samples})\)</span> where the volumes of these voronoi
cells are assumed to be equal under the MC assumption.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>samples</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of shape (num_samples, ndim)) &#8211; The samples in parameter space for which the model was run.</li>
<li><strong>data</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of size (num_samples, mdim)) &#8211; The data from running the model given the samples.</li>
<li><strong>rho_D_M</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of shape  (M,)) &#8211; The simple function approximation of rho_D</li>
<li><strong>d_distr_samples</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of shape  (M, mdim)) &#8211; The samples in the data space that define a
parition of D to for the simple function approximation</li>
<li><strong>d_Tree</strong> &#8211; <code class="xref py py-class docutils literal"><span class="pre">KDTree</span></code> for d_distr_samples</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">tuple of <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of sizes (num_samples,),
(num_samples,), (ndim, num_l_emulate), (num_samples,), (num_l_emulate,)</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(P, lam_vol, io_ptr) where P is the
probability associated with samples, and lam_vol the volumes associated
with the samples, io_ptr a pointer from data to M bins.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.calculateP.calculateP.prob_emulated">
<code class="descclassname">bet.calculateP.calculateP.</code><code class="descname">prob_emulated</code><span class="sig-paren">(</span><em>samples</em>, <em>data</em>, <em>rho_D_M</em>, <em>d_distr_samples</em>, <em>lambda_emulate=None</em>, <em>d_Tree=None</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.calculateP.prob_emulated" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <span class="math">\(P_{\Lambda}(\mathcal{V}_{\lambda_{emulate}})\)</span>, the
probability assoicated with a set of voronoi cells defined by
<code class="docutils literal"><span class="pre">num_l_emulate</span></code> iid samples <span class="math">\((\lambda_{emulate})\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>samples</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of shape (num_samples, ndim)) &#8211; The samples in parameter space for which the model was run.</li>
<li><strong>data</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of size (num_samples, mdim)) &#8211; The data from running the model given the samples.</li>
<li><strong>rho_D_M</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of shape  (M,)) &#8211; The simple function approximation of rho_D</li>
<li><strong>d_distr_samples</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of shape  (M, mdim)) &#8211; The samples in the data space that define a
parition of D to for the simple function approximation</li>
<li><strong>d_Tree</strong> &#8211; <code class="xref py py-class docutils literal"><span class="pre">KDTree</span></code> for d_distr_samples</li>
<li><strong>lambda_emulate</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of shape (num_l_emulate, ndim)) &#8211; Samples used to partition the parameter space</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference external" href="https://docs.python.org/2.7/library/functions.html#tuple" title="(in Python v2.7)">tuple</a></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(P, lambda_emulate, io_ptr, emulate_ptr, lam_vol)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.calculateP.calculateP.prob_mc">
<code class="descclassname">bet.calculateP.calculateP.</code><code class="descname">prob_mc</code><span class="sig-paren">(</span><em>samples</em>, <em>data</em>, <em>rho_D_M</em>, <em>d_distr_samples</em>, <em>lambda_emulate=None</em>, <em>d_Tree=None</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.calculateP.prob_mc" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <span class="math">\(P_{\Lambda}(\mathcal{V}_{\lambda_{samples}})\)</span>, the
probability assoicated with a set of voronoi cells defined by the model
solves at <span class="math">\((\lambda_{samples})\)</span> where the volumes of these voronoi
cells are approximated using MC integration.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>samples</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of shape (num_samples, ndim)) &#8211; The samples in parameter space for which the model was run.</li>
<li><strong>data</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of size (num_samples, mdim)) &#8211; The data from running the model given the samples.</li>
<li><strong>rho_D_M</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of shape  (M,)) &#8211; The simple function approximation of rho_D</li>
<li><strong>d_distr_samples</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of shape  (M, mdim)) &#8211; The samples in the data space that define a
parition of D to for the simple function approximation</li>
<li><strong>d_Tree</strong> &#8211; <code class="xref py py-class docutils literal"><span class="pre">KDTree</span></code> for d_distr_samples</li>
<li><strong>lambda_emulate</strong> &#8211; Samples used to partition the parameter space</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">tuple of <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of sizes (num_samples,),
(num_samples,), (ndim, num_l_emulate), (num_samples,), (num_l_emulate,)</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(P, lam_vol, lambda_emulate, io_ptr, emulate_ptr) where P is the
probability associated with samples, lam_vol the volumes associated
with the samples, io_ptr a pointer from data to M bins, and emulate_ptr
a pointer from emulated samples to samples (in parameter space)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-bet.calculateP.simpleFunP">
<span id="bet-calculatep-simplefunp-module"></span><h2>bet.calculateP.simpleFunP module<a class="headerlink" href="#module-bet.calculateP.simpleFunP" title="Permalink to this headline">¶</a></h2>
<p>This module provides methods for creating simple funciton approximations to be
used by <a class="reference internal" href="#module-bet.calculateP.calculateP" title="bet.calculateP.calculateP"><code class="xref py py-mod docutils literal"><span class="pre">calculateP</span></code></a>.</p>
<dl class="function">
<dt id="bet.calculateP.simpleFunP.normal_normal">
<code class="descclassname">bet.calculateP.simpleFunP.</code><code class="descname">normal_normal</code><span class="sig-paren">(</span><em>Q_ref</em>, <em>M</em>, <em>std</em>, <em>num_d_emulate=1000000.0</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.simpleFunP.normal_normal" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a simple function approximation of <span class="math">\(\rho_{\mathcal{D},M}\)</span>
where <span class="math">\(\rho_{\mathcal{D},M}\)</span> is a multivariate normal probability
density centered at Q_ref with standard deviation std using M bins sampled
from the given normal distribution.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>M</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; Defines number M samples in D used to define
<span class="math">\(\rho_{\mathcal{D},M}\)</span> The choice of M is something of an &#8220;art&#8221; -
play around with it and you can get reasonable results with a
relatively small number here like 50.</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>int num_d_emulate: Number of samples used to emulate using an MC</dt>
<dd>assumption</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Q_ref</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of size (mdim,)) &#8211; <span class="math">\(Q(\lambda_{reference})\)</span></li>
<li><strong>std</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of size (mdim,)) &#8211; The standard deviation of each QoI</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference external" href="https://docs.python.org/2.7/library/functions.html#tuple" title="(in Python v2.7)">tuple</a></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(rho_D_M, d_distr_samples, d_Tree) where <code class="docutils literal"><span class="pre">rho_D_M</span></code>  is (M,) and</p>
</td>
</tr>
</tbody>
</table>
<p><code class="docutils literal"><span class="pre">d_distr_samples</span></code> are (M, mdim) <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> and <cite>d_Tree</cite> is
the <code class="xref py py-class docutils literal"><span class="pre">KDTree</span></code> for d_distr_samples</p>
</dd></dl>

<dl class="function">
<dt id="bet.calculateP.simpleFunP.unif_normal">
<code class="descclassname">bet.calculateP.simpleFunP.</code><code class="descname">unif_normal</code><span class="sig-paren">(</span><em>Q_ref</em>, <em>M</em>, <em>std</em>, <em>num_d_emulate=1000000.0</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.simpleFunP.unif_normal" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a simple function approximation of <span class="math">\(\rho_{\mathcal{D},M}\)</span>
where <span class="math">\(\rho_{\mathcal{D},M}\)</span> is a multivariate normal probability
density centered at Q_ref with standard deviation std using M bins sampled
from a uniform distribution with a size 4 standard deviations in each
direction.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>M</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; Defines number M samples in D used to define
<span class="math">\(\rho_{\mathcal{D},M}\)</span> The choice of M is something of an &#8220;art&#8221; -
play around with it and you can get reasonable results with a
relatively small number here like 50.</li>
<li><strong>num_d_emulate</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; Number of samples used to emulate using an MC
assumption</li>
<li><strong>Q_ref</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of size (mdim,)) &#8211; <span class="math">\(Q(\lambda_{reference})\)</span></li>
<li><strong>std</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of size (mdim,)) &#8211; The standard deviation of each QoI</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference external" href="https://docs.python.org/2.7/library/functions.html#tuple" title="(in Python v2.7)">tuple</a></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(rho_D_M, d_distr_samples, d_Tree) where <code class="docutils literal"><span class="pre">rho_D_M</span></code> is (M,) and</p>
</td>
</tr>
</tbody>
</table>
<p><code class="docutils literal"><span class="pre">d_distr_samples</span></code> are (M, mdim) <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> and <cite>d_Tree</cite> is
the <code class="xref py py-class docutils literal"><span class="pre">KDTree</span></code> for d_distr_samples</p>
</dd></dl>

<dl class="function">
<dt id="bet.calculateP.simpleFunP.unif_unif">
<code class="descclassname">bet.calculateP.simpleFunP.</code><code class="descname">unif_unif</code><span class="sig-paren">(</span><em>data</em>, <em>Q_ref</em>, <em>M=50</em>, <em>bin_ratio=0.2</em>, <em>num_d_emulate=1000000.0</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.simpleFunP.unif_unif" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a simple function approximation of <span class="math">\(\rho_{\mathcal{D}}\)</span>
where <span class="math">\(\rho_{\mathcal{D}}\)</span> is a uniform probability density on
a generalized rectangle centered at Q_ref.
The support of this density is defined by bin_ratio, which determines
the size of the generalized rectangle by scaling the circumscribing 
generalized rectangle of <span class="math">\(\mathcal{D}\)</span>.
The simple function approximation is then defined by determining M 
Voronoi cells (i.e., &#8220;bins&#8221;) partitioning <span class="math">\(\mathcal{D}\)</span>. These
bins are only implicitly defined by M samples in <span class="math">\(\mathcal{D}\)</span>.
Finally, the probabilities of each of these bins is computed by 
sampling from <span class="math">\(\rho{\mathcal{D}}\)</span> and using nearest neighbor 
searches to bin these samples in the M implicitly defined bins. 
The result is the simple function approximation denoted by
<span class="math">\(\rho_{\mathcal{D},M}\)</span>.</p>
<p>Note that all computations in the measure-theoretic framework that
follow from this are for the fixed simple function approximation
<span class="math">\(\rho_{\mathcal{D},M}\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>M</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; Defines number M samples in D used to define
<span class="math">\(\rho_{\mathcal{D},M}\)</span> The choice of M is something of an &#8220;art&#8221; -
play around with it and you can get reasonable results with a
relatively small number here like 50.</li>
<li><strong>bin_ratio</strong> (<em>double or list()</em>) &#8211; The ratio used to determine the width of the
uniform distributiion as <code class="docutils literal"><span class="pre">bin_size</span> <span class="pre">=</span> <span class="pre">(data_max-data_min)*bin_ratio</span></code></li>
<li><strong>num_d_emulate</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; Number of samples used to emulate using an MC
assumption</li>
<li><strong>data</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of size (num_samples, mdim)) &#8211; Array containing QoI data where the QoI is mdim
diminsional</li>
<li><strong>Q_ref</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of size (mdim,)) &#8211; <span class="math">\(Q(\)</span>lambda_{reference})`</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference external" href="https://docs.python.org/2.7/library/functions.html#tuple" title="(in Python v2.7)">tuple</a></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(rho_D_M, d_distr_samples, d_Tree) where <code class="docutils literal"><span class="pre">rho_D_M</span></code> is (M,) and</p>
</td>
</tr>
</tbody>
</table>
<p><code class="docutils literal"><span class="pre">d_distr_samples</span></code> are (M, mdim) <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> and <cite>d_Tree</cite> is
the <code class="xref py py-class docutils literal"><span class="pre">KDTree</span></code> for d_distr_samples</p>
</dd></dl>

<dl class="function">
<dt id="bet.calculateP.simpleFunP.uniform_data">
<code class="descclassname">bet.calculateP.simpleFunP.</code><code class="descname">uniform_data</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.simpleFunP.uniform_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a simple function approximation of <span class="math">\(\rho_{\mathcal{D},M}\)</span>
where <span class="math">\(\rho_{\mathcal{D},M}\)</span> is a uniform probability density over
the entire <code class="docutils literal"><span class="pre">data_domain</span></code>. Here the <code class="docutils literal"><span class="pre">data_domain</span></code> is the union of
voronoi cells defined by <code class="docutils literal"><span class="pre">data</span></code>. In other words we assign each sample the
same probability, so <code class="docutils literal"><span class="pre">M</span> <span class="pre">=</span> <span class="pre">len(data)</span></code> or rather <code class="docutils literal"><span class="pre">len(d_distr_samples)</span> <span class="pre">==</span>
<span class="pre">len(data)</span></code>. The purpose of this method is to approximate uniform
distributions over irregularly shaped domains.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of size (num_samples, mdim)) &#8211; Array containing QoI data where the QoI is mdim diminsional</li>
<li><strong>center_pts_per_edge</strong> (<em>list()</em>) &#8211; number of center points per edge and
additional two points will be added to create the bounding layer</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference external" href="https://docs.python.org/2.7/library/functions.html#tuple" title="(in Python v2.7)">tuple</a></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(rho_D_M, d_distr_samples, d_Tree) where <code class="docutils literal"><span class="pre">rho_D_M</span></code> is (M,) and
<code class="docutils literal"><span class="pre">d_distr_samples</span></code> are (M, mdim) <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> and <cite>d_Tree</cite>
is the <code class="xref py py-class docutils literal"><span class="pre">KDTree</span></code> for d_distr_samples</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.calculateP.simpleFunP.uniform_hyperrectangle">
<code class="descclassname">bet.calculateP.simpleFunP.</code><code class="descname">uniform_hyperrectangle</code><span class="sig-paren">(</span><em>data</em>, <em>Q_ref</em>, <em>bin_ratio</em>, <em>center_pts_per_edge=1</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.simpleFunP.uniform_hyperrectangle" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a simple function approximation of <span class="math">\(\rho_{\mathcal{D},M}\)</span>
where <span class="math">\(\rho_{\mathcal{D},M}\)</span> is a uniform probability density
centered at Q_ref with bin_ratio of the width
of D.</p>
<p>Since rho_D is a uniform distribution on a hyperrectanlge we should be able
to represent it exactly with <code class="docutils literal"><span class="pre">M</span> <span class="pre">=</span> <span class="pre">3^mdim</span></code> or rather
<code class="docutils literal"><span class="pre">len(d_distr_samples)</span> <span class="pre">==</span> <span class="pre">3^mdim</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>bin_ratio</strong> (<em>double or list()</em>) &#8211; The ratio used to determine the width of the
uniform distributiion as <code class="docutils literal"><span class="pre">bin_size</span> <span class="pre">=</span> <span class="pre">(data_max-data_min)*bin_ratio</span></code></li>
<li><strong>num_d_emulate</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; Number of samples used to emulate using an MC
assumption</li>
<li><strong>data</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of size (num_samples, mdim)) &#8211; Array containing QoI data where the QoI is mdim diminsional</li>
<li><strong>Q_ref</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of size (mdim,)) &#8211; <span class="math">\(Q(\lambda_{reference})\)</span></li>
<li><strong>center_pts_per_edge</strong> (<em>list()</em>) &#8211; number of center points per edge and
additional two points will be added to create the bounding layer</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference external" href="https://docs.python.org/2.7/library/functions.html#tuple" title="(in Python v2.7)">tuple</a></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(rho_D_M, d_distr_samples, d_Tree) where <code class="docutils literal"><span class="pre">rho_D_M</span></code> is (M,) and
<code class="docutils literal"><span class="pre">d_distr_samples</span></code> are (M, mdim) <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> and <cite>d_Tree</cite>
is the <code class="xref py py-class docutils literal"><span class="pre">KDTree</span></code> for d_distr_samples</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.calculateP.simpleFunP.uniform_hyperrectangle_binsize">
<code class="descclassname">bet.calculateP.simpleFunP.</code><code class="descname">uniform_hyperrectangle_binsize</code><span class="sig-paren">(</span><em>data</em>, <em>Q_ref</em>, <em>bin_size</em>, <em>center_pts_per_edge=1</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.simpleFunP.uniform_hyperrectangle_binsize" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a simple function approximation of <span class="math">\(\rho_{\mathcal{D},M}\)</span>
where <span class="math">\(\rho_{\mathcal{D},M}\)</span> is a uniform probability density
centered at Q_ref with bin_size of the width of D.</p>
<p>Since rho_D is a uniform distribution on a hyperrectanlge we should be able
to represent it exactly with <code class="docutils literal"><span class="pre">M</span> <span class="pre">=</span> <span class="pre">3^mdim</span></code> or rather
<code class="docutils literal"><span class="pre">len(d_distr_samples)</span> <span class="pre">==</span> <span class="pre">3^mdim</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>bin_size</strong> (<em>double or list()</em>) &#8211; The size used to determine the width of the uniform
distribution</li>
<li><strong>num_d_emulate</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; Number of samples used to emulate using an MC 
assumption</li>
<li><strong>data</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of size (num_samples, mdim)) &#8211; Array containing QoI data where the QoI is mdim diminsional</li>
<li><strong>Q_ref</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of size (mdim,)) &#8211; <span class="math">\(Q(\lambda_{reference})\)</span></li>
<li><strong>center_pts_per_edge</strong> (<em>list()</em>) &#8211; number of center points per edge
and additional two points will be added to create the bounding layer</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">tuple :returns: (rho_D_M, d_distr_samples, d_Tree) where</p>
</td>
</tr>
</tbody>
</table>
<p><code class="docutils literal"><span class="pre">rho_D_M</span></code> is (M,) and <code class="docutils literal"><span class="pre">d_distr_samples</span></code> are (M, mdim)
<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> and <cite>d_Tree</cite> is the <code class="xref py py-class docutils literal"><span class="pre">KDTree</span></code>
for d_distr_samples</p>
</dd></dl>

<dl class="function">
<dt id="bet.calculateP.simpleFunP.uniform_hyperrectangle_user">
<code class="descclassname">bet.calculateP.simpleFunP.</code><code class="descname">uniform_hyperrectangle_user</code><span class="sig-paren">(</span><em>data</em>, <em>domain</em>, <em>center_pts_per_edge=1</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.simpleFunP.uniform_hyperrectangle_user" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a simple funciton appoximation of <span class="math">\(\rho_{\mathcal{D},M}\)</span>
where <span class="math">\(\rho{\mathcal{D}, M}\)</span> is a uniform probablity density over the
hyperrectangular domain specified by domain.</p>
<p>Since <span class="math">\(\rho_\mathcal{D}\)</span> is a uniform distribution on a
hyperrectangle we should we able to represent it exactly with
<span class="math">\(M=3^{m}\)</span> where m is the dimension of the data space or rather
<code class="docutils literal"><span class="pre">len(d_distr_samples)</span> <span class="pre">==</span> <span class="pre">3**mdim</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of size (num_samples, mdim)) &#8211; Array containing QoI data where the QoI is mdim diminsional</li>
<li><strong>domain</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> of shape (2, mdim)) &#8211; The domain overwhich <span class="math">\(\rho_\mathcal{D}\)</span> is
uniform.</li>
<li><strong>center_pts_per_edge</strong> (<em>list()</em>) &#8211; number of center points per edge and
additional two points will be added to create the bounding layer</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference external" href="https://docs.python.org/2.7/library/functions.html#tuple" title="(in Python v2.7)">tuple</a></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(rho_D_M, d_distr_samples, d_Tree) where <code class="docutils literal"><span class="pre">rho_D_M</span></code> is (M,) and
<code class="docutils literal"><span class="pre">d_distr_samples</span></code> are (M, mdim) <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> and <cite>d_Tree</cite>
is the <code class="xref py py-class docutils literal"><span class="pre">KDTree</span></code> for d_distr_samples</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-bet.calculateP.voronoiHistogram">
<span id="bet-calculatep-voronoihistogram-module"></span><h2>bet.calculateP.voronoiHistogram module<a class="headerlink" href="#module-bet.calculateP.voronoiHistogram" title="Permalink to this headline">¶</a></h2>
<p>This module provides methods for creating the edges and generating point for
regular (hyperrectangle) multidimensional voronoi cells and for determining the
volumes of these cells.</p>
<dl class="function">
<dt id="bet.calculateP.voronoiHistogram.center_and_layer1_points">
<code class="descclassname">bet.calculateP.voronoiHistogram.</code><code class="descname">center_and_layer1_points</code><span class="sig-paren">(</span><em>center_pts_per_edge</em>, <em>center</em>, <em>r_ratio</em>, <em>sur_domain</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.voronoiHistogram.center_and_layer1_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a regular grid of center points that define the voronoi
tesselation of exactly the interior of a hyperrectangle centered at
<code class="docutils literal"><span class="pre">center</span></code> with sides of length <code class="docutils literal"><span class="pre">r_ratio*sur_width</span></code> and the layers
of voronoi cells that bound these interior cells. The resulting voronoi
tesselation exactly represents the hyperrectangle.</p>
<p>This method can also be used to tile <code class="docutils literal"><span class="pre">sur_domain</span></code> with points to define
voronoi regions if the user sets <code class="docutils literal"><span class="pre">r_ratio</span> <span class="pre">=</span> <span class="pre">1</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>center_pts_per_edge</strong> (<em>list()</em>) &#8211; number of center points per edge and
additional two points will be added to create the bounding layer</li>
<li><strong>center</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> of shape (mdim,)) &#8211; location of the center of the hyperrectangle</li>
<li><strong>r_ratio</strong> (<em>double or list()</em>) &#8211; ratio of the length of the sides of the
hyperrectangle rect_domain to definie voronoi cells for</li>
<li><strong>sur_domain</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> of shape (mdim, 2)) &#8211; minima and maxima of each dimension defining the
surrounding domain. The surrounding domain is the bounded domain
in the data space (i.e. the data domain).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference external" href="https://docs.python.org/2.7/library/functions.html#tuple" title="(in Python v2.7)">tuple</a></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(points, interior_and_layer1, rect_domain) where where points is
an <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> of shape (num_points, dim),
interior_and_layer1 is a list() of dim <code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray`s</span> <span class="pre">of</span> <span class="pre">shape</span>
<span class="pre">(center_pts_per_edge+2,),</span> <span class="pre">rect_domain</span> <span class="pre">is</span> <span class="pre">a</span> <span class="pre">:class:`numpy.ndarray</span></code> of
shape (mdim, 2).</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.calculateP.voronoiHistogram.center_and_layer1_points_binsize">
<code class="descclassname">bet.calculateP.voronoiHistogram.</code><code class="descname">center_and_layer1_points_binsize</code><span class="sig-paren">(</span><em>center_pts_per_edge</em>, <em>center</em>, <em>r_size</em>, <em>sur_domain</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.voronoiHistogram.center_and_layer1_points_binsize" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a regular grid of center points that define the voronoi
tesselation of exactly the interior of a hyperrectangle centered at
<code class="docutils literal"><span class="pre">center</span></code> with sides of length <code class="docutils literal"><span class="pre">r_size</span></code> and the layers
of voronoi cells that bound these interior cells. The resulting voronoi
tesselation exactly represents the hyperrectangle.</p>
<p>This method can also be used to tile <code class="docutils literal"><span class="pre">sur_domain</span></code> with points to define
voronoi regions if the user sets <code class="docutils literal"><span class="pre">r_ratio</span> <span class="pre">=</span> <span class="pre">1</span></code>. (use binratio)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>center_pts_per_edge</strong> (<em>list()</em>) &#8211; number of center points per edge and
additional two points will be added to create the bounding layer</li>
<li><strong>center</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> of shape (mdim,)) &#8211; location of the center of the hyperrectangle</li>
<li><strong>r_size</strong> (<em>double or list()</em>) &#8211; size of the length of the sides of the
hyperrectangle rect_domain to definie voronoi cells for</li>
<li><strong>sur_domain</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> of shape (mdim, 2)) &#8211; minima and maxima of each dimension defining the
surrounding domain. The surrounding domain is the bounded domain
in the data space (i.e. the data domain).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference external" href="https://docs.python.org/2.7/library/functions.html#tuple" title="(in Python v2.7)">tuple</a></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(points, interior_and_layer1, rect_domain) where where points is
an <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> of shape (num_points, dim),
interior_and_layer1 is a list() of dim <code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray`s</span> <span class="pre">of</span> <span class="pre">shape</span>
<span class="pre">(center_pts_per_edge+2,),</span> <span class="pre">rect_domain</span> <span class="pre">is</span> <span class="pre">a</span> <span class="pre">:class:`numpy.ndarray</span></code> of
shape (mdim, 2)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.calculateP.voronoiHistogram.edges_from_points">
<code class="descclassname">bet.calculateP.voronoiHistogram.</code><code class="descname">edges_from_points</code><span class="sig-paren">(</span><em>points</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.voronoiHistogram.edges_from_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a sequence of arrays describing the voronoi points in each dimension
that define a set of bounded hyperrectangular bins returns the edges of bins
formed by voronoi cells along each dimensions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>points</strong> (list of dim :class:<a href="#id1"><span class="problematic" id="id2">`</span></a>numpy.ndarray`s of shape (nbins+2,)) &#8211; the coordindates of voronoi points that would generate
these bins in each dimensions</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">edges, A sequence of arrays describing the edges of bins along
each dimension.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Rtype edges:</th><td class="field-body">A list() containing mdim :class:<a href="#id3"><span class="problematic" id="id4">`</span></a>numpy.ndarray`s of shape
(nbins_per_dim+1,)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.calculateP.voronoiHistogram.edges_regular">
<code class="descclassname">bet.calculateP.voronoiHistogram.</code><code class="descname">edges_regular</code><span class="sig-paren">(</span><em>center_pts_per_edge</em>, <em>rect_domain</em>, <em>sur_domain</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.voronoiHistogram.edges_regular" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a sequence of arrays describing the edges of the finite voronoi
cells in each direction. The voronoi tesselation is defined by regular grid
of center points that define the voronoi tesselation of exactly the
interior of a hyperrectangle  defined by <code class="docutils literal"><span class="pre">rect_domain</span></code>  and the layers of
voronoi cells that bound these interior cells. The resulting voronoi
tesselation exactly represents the hyperrectangle. The bounding voronoi
cells are made finite by bounding them with an  additional layer to
represent <code class="docutils literal"><span class="pre">sur_domain</span></code>.</p>
<p>This method can also be used to tile <code class="docutils literal"><span class="pre">sur_domain</span></code> with points to define
voronoi regions if the user sets <code class="docutils literal"><span class="pre">r_ratio</span> <span class="pre">=</span> <span class="pre">1</span></code>. use binratio below</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>center_pts_per_edge</strong> (<em>list()</em>) &#8211; number of center points per edge and
additional two points will be added to create the bounding layer</li>
<li><strong>rect_domain</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> of shape (mdim, 2)) &#8211; The rectangular domain to define the voronoi
tesselation for. This domain should be contained in the <code class="docutils literal"><span class="pre">sur_domain</span></code>.</li>
<li><strong>sur_domain</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> of shape (mdim, 2)) &#8211; minima and maxima of each dimension defining the
surrounding domain. The surrounding domain is the bounded domain
in the data space (i.e. the data domain).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference external" href="https://docs.python.org/2.7/library/functions.html#tuple" title="(in Python v2.7)">tuple</a></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">interior_and_layer1 is a list of dim :class:<a href="#id5"><span class="problematic" id="id6">`</span></a>numpy.ndarray`s of
shape (center_pts_per_edge+2,)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.calculateP.voronoiHistogram.histogramdd_volumes">
<code class="descclassname">bet.calculateP.voronoiHistogram.</code><code class="descname">histogramdd_volumes</code><span class="sig-paren">(</span><em>edges</em>, <em>points</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.voronoiHistogram.histogramdd_volumes" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a sequence of arrays describing the edges of voronoi cells (bins)
along each dimension and an &#8216;ij&#8217; ordered sequence of points (1 per voronoi
cell) returns a list of the volumes associated with these voronoi cells.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>edges</strong> (A list() containing mdim :class:<a href="#id7"><span class="problematic" id="id8">`</span></a>numpy.ndarray`s of shape
(nbins_per_dim+1,)) &#8211; A sequence of arrays describing the edges of bins along
each dimension.</li>
<li><strong>points</strong> (<code class="xref py py-class docutils literal"><span class="pre">numpy.ndarrray</span></code> of shape (num_points, mdim)) &#8211; points used to define the voronoi tesselation (only the
points that define regions of finite volumes)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">tuple of (H, volume, edges)</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">H is the result of <code class="xref py py-meth docutils literal"><span class="pre">np.histogramdd(points,</span> <span class="pre">edges,</span>
<span class="pre">normed=True)()</span></code>, volumes is a <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> of shape
(len(points),) continaing the  finite volumes associated with
<code class="docutils literal"><span class="pre">points</span></code></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.calculateP.voronoiHistogram.simple_fun_uniform">
<code class="descclassname">bet.calculateP.voronoiHistogram.</code><code class="descname">simple_fun_uniform</code><span class="sig-paren">(</span><em>points</em>, <em>volumes</em>, <em>rect_domain</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.voronoiHistogram.simple_fun_uniform" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a set of points, the volumes associated with these points, and
<code class="docutils literal"><span class="pre">rect_domain</span></code> creates a simple function approximation of a uniform
distribution over the hyperrectangle defined by <code class="docutils literal"><span class="pre">rect_domain</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>points</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> of shape (num_points,)) &#8211; points used to define the voronoi tesselation (only the
points that define regions of finite volumes)</li>
<li><strong>volumes</strong> (<em>list()</em>) &#8211; finite volumes associated with <code class="docutils literal"><span class="pre">points</span></code></li>
<li><strong>rect_domain</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> of shape (mdim, 2)) &#8211; minima and maxima of each dimension defining the
hyperrectangle of uniform probability</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference external" href="https://docs.python.org/2.7/library/functions.html#tuple" title="(in Python v2.7)">tuple</a></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(rho_D_M, points, d_Tree) where <code class="docutils literal"><span class="pre">rho_D_M</span></code> and
<code class="docutils literal"><span class="pre">points</span></code> are (mdim, M) <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> and
<cite>d_Tree</cite> is the <code class="xref py py-class docutils literal"><span class="pre">KDTree</span></code> for points</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-bet.calculateP">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-bet.calculateP" title="Permalink to this headline">¶</a></h2>
<p>This subpackage provides classes and methods for calulating the
probability measure <span class="math">\(P_{\Lambda}\)</span>.</p>
<ul>
<li><dl class="first docutils">
<dt><a class="reference internal" href="#module-bet.calculateP.calculateP" title="bet.calculateP.calculateP"><code class="xref py py-mod docutils literal"><span class="pre">calculateP</span></code></a> provides methods for approximating</dt>
<dd><p class="first last">probability densities</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><a class="reference internal" href="#module-bet.calculateP.simpleFunP" title="bet.calculateP.simpleFunP"><code class="xref py py-mod docutils literal"><span class="pre">simpleFunP</span></code></a> provides methods for creating simple</dt>
<dd><p class="first last">function approximations of probability densisties</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><a class="reference internal" href="#module-bet.calculateP.voronoiHistogram" title="bet.calculateP.voronoiHistogram"><code class="xref py py-mod docutils literal"><span class="pre">voronoiHistogram</span></code></a> provides methods for creating the</dt>
<dd><p class="first last">generating points for cells that define a regular grid for use by
<code class="xref py py-meth docutils literal"><span class="pre">numpy.histogramdd()</span></code> and for determining their volumes, etc. This
module is only for use by <a class="reference internal" href="#module-bet.calculateP.simpleFunP" title="bet.calculateP.simpleFunP"><code class="xref py py-mod docutils literal"><span class="pre">simpleFunP</span></code></a>.</p>
</dd>
</dl>
</li>
</ul>
</div>
</div>


          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="bet.postProcess.html" class="btn btn-neutral float-right" title="bet.postProcess package">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="bet.html" class="btn btn-neutral" title="bet package"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2014, The BET Development Team (Lindley Graham, Steven Mattis, Troy Butler).
      Last updated on Jul 14, 2015.
    </p>
  </div>

  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
  
</footer>
        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.0.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>