<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>bet.calculateP package &mdash; BET 0.0 documentation</title>
    
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="BET 0.0 documentation" href="index.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9">

  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">BET 0.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="bet-calculatep-package">
<h1>bet.calculateP package<a class="headerlink" href="#bet-calculatep-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-bet.calculateP.calculateP">
<span id="bet-calculatep-calculatep-module"></span><h2>bet.calculateP.calculateP module<a class="headerlink" href="#module-bet.calculateP.calculateP" title="Permalink to this headline">¶</a></h2>
<p>This module provides methods for calulating the probability
measure <span class="math">\(P_{\Lambda}\)</span>.</p>
<ul>
<li><dl class="first docutils">
<dt><code class="xref py py-mod docutils literal"><span class="pre">prob_emulated</span></code> provides a skeleton class and calculates</dt>
<dd><p class="first last">the probability for a set of emulation points.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="xref py py-mod docutils literal"><span class="pre">prob_samples_ex</span></code> calculates the exact</dt>
<dd><p class="first last">volumes of the interior voronoi cells and estimates the volumes of the
exterior voronoi cells by using a set of bounding points</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="xref py py-mod docutils literal"><span class="pre">prob_samples_mc</span></code> estimates the volumes of</dt>
<dd><p class="first last">the voronoi cells using MC integration</p>
</dd>
</dl>
</li>
</ul>
<dl class="function">
<dt id="bet.calculateP.calculateP.emulate_iid_lebesgue">
<code class="descclassname">bet.calculateP.calculateP.</code><code class="descname">emulate_iid_lebesgue</code><span class="sig-paren">(</span><em>lam_domain</em>, <em>num_l_emulate</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.calculateP.emulate_iid_lebesgue" title="Permalink to this definition">¶</a></dt>
<dd><p>Parition the parameter space using emulated samples into many voronoi cells.
These samples are iid so that we can apply the standard MC                                       
assumuption/approximation</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lam_domain</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of shape (ndim, 2)) &#8211; The domain for each parameter for the model.</li>
<li><strong>num_l_emulate</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; The number of emulated samples.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of shape (num_l_emulate, ndim)</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a set of samples for emulation</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.calculateP.calculateP.prob">
<code class="descclassname">bet.calculateP.calculateP.</code><code class="descname">prob</code><span class="sig-paren">(</span><em>samples</em>, <em>data</em>, <em>rho_D_M</em>, <em>d_distr_samples</em>, <em>lam_domain</em>, <em>d_Tree=None</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.calculateP.prob" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <span class="math">\(P_{\Lambda}(\mathcal{V}_{\lambda_{samples}})\)</span>, the
probability assoicated with a set of voronoi cells defined by the model
solves at <span class="math">\((\lambda_{samples})\)</span> where the volumes of these voronoi
cells are assumed to be equal under the MC assumption.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>samples</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of shape (num_samples, ndim)) &#8211; The samples in parameter space for which the model was run.</li>
<li><strong>data</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of size (num_samples, mdim)) &#8211; The data from running the model given the samples.</li>
<li><strong>rho_D_M</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of shape  (M,mdim)) &#8211; The simple function approximation of rho_D</li>
<li><strong>d_distr_samples</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of shape  (M, mdim)) &#8211; The samples in the data space that define a
parition of D to for the simple function approximation</li>
<li><strong>d_Tree</strong> &#8211; <code class="xref py py-class docutils literal"><span class="pre">KDTree</span></code> for d_distr_samples</li>
<li><strong>lam_domain</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of shape (ndim, 2)) &#8211; The domain for each parameter for the model.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">tuple of <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of sizes (num_samples,),
(num_samples,), (ndim, num_l_emulate), (num_samples,), (num_l_emulate,)</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(P, lam_vol, lambda_emulate, io_ptr, emulate_ptr) where P is the
probability associated with samples, lam_vol the volumes associated
with the samples, io_ptr a pointer from data to M bins, and emulate_ptr
a pointer from emulated samples to samples (in parameter space)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.calculateP.calculateP.prob_emulated">
<code class="descclassname">bet.calculateP.calculateP.</code><code class="descname">prob_emulated</code><span class="sig-paren">(</span><em>samples</em>, <em>data</em>, <em>rho_D_M</em>, <em>d_distr_samples</em>, <em>lam_domain</em>, <em>lambda_emulate=None</em>, <em>d_Tree=None</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.calculateP.prob_emulated" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <span class="math">\(P_{\Lambda}(\mathcal{V}_{\lambda_{emulate}})\)</span>, the
probability assoicated with a set of voronoi cells defined by
<code class="docutils literal"><span class="pre">num_l_emulate</span></code> iid samples <span class="math">\((\lambda_{emulate})\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>samples</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of shape (num_samples, ndim)) &#8211; The samples in parameter space for which the model was run.</li>
<li><strong>data</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of size (num_samples, mdim)) &#8211; The data from running the model given the samples.</li>
<li><strong>rho_D_M</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of shape  (M,mdim)) &#8211; The simple function approximation of rho_D</li>
<li><strong>d_distr_samples</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of shape  (M, mdim)) &#8211; The samples in the data space that define a
parition of D to for the simple function approximation</li>
<li><strong>d_Tree</strong> &#8211; <code class="xref py py-class docutils literal"><span class="pre">KDTree</span></code> for d_distr_samples</li>
<li><strong>lam_domain</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of shape (ndim, 2)) &#8211; The domain for each parameter for the model.</li>
<li><strong>lambda_emulate</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of shape (num_l_emulate, ndim)) &#8211; Samples used to partition the parameter space</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference external" href="https://docs.python.org/2.7/library/functions.html#tuple" title="(in Python v2.7)">tuple</a></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(P, lambda_emulate, io_ptr, emulate_ptr, lam_vol)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.calculateP.calculateP.prob_mc">
<code class="descclassname">bet.calculateP.calculateP.</code><code class="descname">prob_mc</code><span class="sig-paren">(</span><em>samples</em>, <em>data</em>, <em>rho_D_M</em>, <em>d_distr_samples</em>, <em>lam_domain</em>, <em>lambda_emulate=None</em>, <em>d_Tree=None</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.calculateP.prob_mc" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <span class="math">\(P_{\Lambda}(\mathcal{V}_{\lambda_{samples}})\)</span>, the
probability assoicated with a set of voronoi cells defined by the model
solves at <span class="math">\((\lambda_{samples})\)</span> where the volumes of these voronoi
cells are approximated using MC integration.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>samples</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of shape (num_samples, ndim)) &#8211; The samples in parameter space for which the model was run.</li>
<li><strong>data</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of size (num_samples, mdim)) &#8211; The data from running the model given the samples.</li>
<li><strong>rho_D_M</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of shape  (M, mdim)) &#8211; The simple function approximation of rho_D</li>
<li><strong>d_distr_samples</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of shape  (M, mdim)) &#8211; The samples in the data space that define a
parition of D to for the simple function approximation</li>
<li><strong>d_Tree</strong> &#8211; <code class="xref py py-class docutils literal"><span class="pre">KDTree</span></code> for d_distr_samples</li>
<li><strong>lam_domain</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of shape (ndim,2)) &#8211; The domain for each parameter for the model.</li>
<li><strong>num_l_emulate</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; The number of iid samples used to parition the
parameter space</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">tuple of <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of sizes (num_samples,),
(num_samples,), (ndim, num_l_emulate), (num_samples,), (num_l_emulate,)</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(P, lam_vol, lambda_emulate, io_ptr, emulate_ptr) where P is the
probability associated with samples, lam_vol the volumes associated
with the samples, io_ptr a pointer from data to M bins, and emulate_ptr
a pointer from emulated samples to samples (in parameter space)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.calculateP.calculateP.prob_qhull">
<code class="descclassname">bet.calculateP.calculateP.</code><code class="descname">prob_qhull</code><span class="sig-paren">(</span><em>samples</em>, <em>data</em>, <em>rho_D_M</em>, <em>d_distr_samples</em>, <em>lam_domain</em>, <em>d_Tree=None</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.calculateP.prob_qhull" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <span class="math">\(P_{\Lambda}(\mathcal{V}_{\lambda_{emulate}})\)</span>, the
probability assoicated with a set of voronoi cells defined by
<code class="docutils literal"><span class="pre">num_l_emulate</span></code> iid samples <span class="math">\((\lambda_{emulate})\)</span>.</p>
<p>This method is only intended when <code class="docutils literal"><span class="pre">lam_domain</span></code> is a generalized rectangle.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>samples</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of shape (num_samples, ndim)) &#8211; The samples in parameter space for which the model was run.</li>
<li><strong>data</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of size (num_samples, mdim)) &#8211; The data from running the model given the samples.</li>
<li><strong>rho_D_M</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of shape  (M,mdim)) &#8211; The simple function approximation of rho_D</li>
<li><strong>d_distr_samples</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of shape  (M,mdim)) &#8211; The samples in the data space that define a
parition of D to for the simple function approximation</li>
<li><strong>d_Tree</strong> &#8211; <code class="xref py py-class docutils literal"><span class="pre">KDTree</span></code> for d_distr_samples</li>
<li><strong>lam_domain</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of shape (ndim, 2)) &#8211; The domain for each parameter for the model.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(P, io_ptr, lam_vol)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-bet.calculateP.simpleFunP">
<span id="bet-calculatep-simplefunp-module"></span><h2>bet.calculateP.simpleFunP module<a class="headerlink" href="#module-bet.calculateP.simpleFunP" title="Permalink to this headline">¶</a></h2>
<p>This module provides methods for creating simple funciton approximations to be
used by <a class="reference internal" href="#module-bet.calculateP.calculateP" title="bet.calculateP.calculateP"><code class="xref py py-mod docutils literal"><span class="pre">calculateP</span></code></a>.</p>
<dl class="function">
<dt id="bet.calculateP.simpleFunP.gaussian_regular">
<code class="descclassname">bet.calculateP.simpleFunP.</code><code class="descname">gaussian_regular</code><span class="sig-paren">(</span><em>data</em>, <em>Q_ref</em>, <em>std</em>, <em>nbins</em>, <em>num_d_emulate=1000000.0</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.simpleFunP.gaussian_regular" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="bet.calculateP.simpleFunP.gaussian_unif">
<code class="descclassname">bet.calculateP.simpleFunP.</code><code class="descname">gaussian_unif</code><span class="sig-paren">(</span><em>data</em>, <em>Q_ref</em>, <em>std</em>, <em>nbins</em>, <em>num_d_emulate=1000000.0</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.simpleFunP.gaussian_unif" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="bet.calculateP.simpleFunP.hist_gaussian">
<code class="descclassname">bet.calculateP.simpleFunP.</code><code class="descname">hist_gaussian</code><span class="sig-paren">(</span><em>data</em>, <em>distr_samples</em>, <em>nbins</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.simpleFunP.hist_gaussian" title="Permalink to this definition">¶</a></dt>
<dd><p>determine mean, standard deviation of distr_samples
partition D into nbins of equal probability for N(mean, sigma)
check to make sure  each bin has about 1 data sample per bin, if not
recompute bins
(hist, edges) = histdd(distr_samples, bins)
determine d_distr_samples from edges</p>
</dd></dl>

<dl class="function">
<dt id="bet.calculateP.simpleFunP.hist_regular">
<code class="descclassname">bet.calculateP.simpleFunP.</code><code class="descname">hist_regular</code><span class="sig-paren">(</span><em>data</em>, <em>distr_samples</em>, <em>nbins</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.simpleFunP.hist_regular" title="Permalink to this definition">¶</a></dt>
<dd><p>create nbins regulary spaced bins
check to make sure  each bin has about 1 data sample per bin, if not
recompute bins
(hist, edges) = histdd(distr_samples, bins)
<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.histogramdd.html#numpy.histogramdd">http://docs.scipy.org/doc/numpy/reference/generated/numpy.histogramdd.html#numpy.histogramdd</a>
determine d_distr_samples from edges</p>
</dd></dl>

<dl class="function">
<dt id="bet.calculateP.simpleFunP.hist_unif">
<code class="descclassname">bet.calculateP.simpleFunP.</code><code class="descname">hist_unif</code><span class="sig-paren">(</span><em>data</em>, <em>distr_samples</em>, <em>nbins</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.simpleFunP.hist_unif" title="Permalink to this definition">¶</a></dt>
<dd><p>same as hist_regular bit with uniformly spaced bins
unif_unif can and should call this function</p>
</dd></dl>

<dl class="function">
<dt id="bet.calculateP.simpleFunP.multivariate_gaussian">
<code class="descclassname">bet.calculateP.simpleFunP.</code><code class="descname">multivariate_gaussian</code><span class="sig-paren">(</span><em>x</em>, <em>mean</em>, <em>std</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.simpleFunP.multivariate_gaussian" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="bet.calculateP.simpleFunP.normal_normal">
<code class="descclassname">bet.calculateP.simpleFunP.</code><code class="descname">normal_normal</code><span class="sig-paren">(</span><em>Q_ref</em>, <em>M</em>, <em>std</em>, <em>num_d_emulate=1000000.0</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.simpleFunP.normal_normal" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a simple function approximation of <span class="math">\(\rho_{\mathcal{D},M}\)</span>
where <span class="math">\(\rho_{\mathcal{D},M}\)</span> is a multivariate normal probability
density centered at Q_ref with standard deviation std using M bins sampled
from the given normal distribution.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>M</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; Defines number M samples in D used to define
<span class="math">\(\rho_{\mathcal{D},M}\)</span> The choice of M is something of an &#8220;art&#8221; -
play around with it and you can get reasonable results with a
relatively small number here like 50.</li>
<li><strong>num_d_emulate</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; Number of samples used to emulate using an MC
assumption</li>
<li><strong>Q_ref</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of size (mdim,)) &#8211; <span class="math">\(Q(\lambda_{reference})\)</span></li>
<li><strong>std</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of size (mdim,)) &#8211; The standard deviation of each QoI</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference external" href="https://docs.python.org/2.7/library/functions.html#tuple" title="(in Python v2.7)">tuple</a></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(rho_D_M, d_distr_samples, d_Tree) where <code class="docutils literal"><span class="pre">rho_D_M</span></code> and</p>
</td>
</tr>
</tbody>
</table>
<p><code class="docutils literal"><span class="pre">d_distr_samples</span></code> are (mdim, M) <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> and <cite>d_Tree</cite> is
the <code class="xref py py-class docutils literal"><span class="pre">KDTree</span></code> for d_distr_samples</p>
</dd></dl>

<dl class="function">
<dt id="bet.calculateP.simpleFunP.unif_normal">
<code class="descclassname">bet.calculateP.simpleFunP.</code><code class="descname">unif_normal</code><span class="sig-paren">(</span><em>Q_ref</em>, <em>M</em>, <em>std</em>, <em>num_d_emulate=1000000.0</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.simpleFunP.unif_normal" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a simple function approximation of <span class="math">\(\rho_{\mathcal{D},M}\)</span>
where <span class="math">\(\rho_{\mathcal{D},M}\)</span> is a multivariate normal probability
density centered at Q_ref with standard deviation std using M bins sampled
from a uniform distribution with a size 4 standard deviations in each
direction.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>M</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; Defines number M samples in D used to define
<span class="math">\(\rho_{\mathcal{D},M}\)</span> The choice of M is something of an &#8220;art&#8221; -
play around with it and you can get reasonable results with a
relatively small number here like 50.</li>
<li><strong>num_d_emulate</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; Number of samples used to emulate using an MC
assumption</li>
<li><strong>Q_ref</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of size (mdim,)) &#8211; <span class="math">\(Q(\lambda_{reference})\)</span></li>
<li><strong>std</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of size (mdim,)) &#8211; The standard deviation of each QoI</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference external" href="https://docs.python.org/2.7/library/functions.html#tuple" title="(in Python v2.7)">tuple</a></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(rho_D_M, d_distr_samples, d_Tree) where <code class="docutils literal"><span class="pre">rho_D_M</span></code> and</p>
</td>
</tr>
</tbody>
</table>
<p><code class="docutils literal"><span class="pre">d_distr_samples</span></code> are (mdim, M) <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> and <cite>d_Tree</cite> is
the <code class="xref py py-class docutils literal"><span class="pre">KDTree</span></code> for d_distr_samples</p>
</dd></dl>

<dl class="function">
<dt id="bet.calculateP.simpleFunP.unif_unif">
<code class="descclassname">bet.calculateP.simpleFunP.</code><code class="descname">unif_unif</code><span class="sig-paren">(</span><em>data</em>, <em>Q_ref</em>, <em>M=50</em>, <em>bin_ratio=0.2</em>, <em>num_d_emulate=1000000.0</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.simpleFunP.unif_unif" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a simple function approximation of <span class="math">\(\rho_{\mathcal{D}}\)</span>
where <span class="math">\(\rho_{\mathcal{D}}\)</span> is a uniform probability density on
a generalized rectangle centered at Q_ref.
The support of this density is defined by bin_ratio, which determines
the size of the generalized rectangle by scaling the circumscribing 
generalized rectangle of <span class="math">\(\mathcal{D}\)</span>.
The simple function approximation is then defined by determining M 
Voronoi cells (i.e., &#8220;bins&#8221;) partitioning <span class="math">\(\mathcal{D}\)</span>. These
bins are only implicitly defined by M samples in <span class="math">\(\mathcal{D}\)</span>.
Finally, the probabilities of each of these bins is computed by 
sampling from <span class="math">\(\rho{\mathcal{D}}\)</span> and using nearest neighbor 
searches to bin these samples in the M implicitly defined bins. 
The result is the simple function approximation denoted by
<span class="math">\(\rho_{\mathcal{D},M}\)</span>.</p>
<p>Note that all computations in the measure-theoretic framework that
follow from this are for the fixed simple function approximation
<span class="math">\(\rho_{\mathcal{D},M}\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>M</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; Defines number M samples in D used to define
<span class="math">\(\rho_{\mathcal{D},M}\)</span> The choice of M is something of an &#8220;art&#8221; -
play around with it and you can get reasonable results with a
relatively small number here like 50.</li>
<li><strong>bin_ratio</strong> (<em>double or list()</em>) &#8211; The ratio used to determine the width of the
uniform distributiion as <code class="docutils literal"><span class="pre">bin_size</span> <span class="pre">=</span> <span class="pre">(data_max-data_min)*bin_ratio</span></code></li>
<li><strong>num_d_emulate</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; Number of samples used to emulate using an MC
assumption</li>
<li><strong>data</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of size (num_samples, mdim)) &#8211; Array containing QoI data where the QoI is mdim
diminsional</li>
<li><strong>Q_ref</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of size (mdim,)) &#8211; <span class="math">\(Q(\)</span>lambda_{reference})`</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference external" href="https://docs.python.org/2.7/library/functions.html#tuple" title="(in Python v2.7)">tuple</a></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(rho_D_M, d_distr_samples, d_Tree) where <code class="docutils literal"><span class="pre">rho_D_M</span></code> and</p>
</td>
</tr>
</tbody>
</table>
<p><code class="docutils literal"><span class="pre">d_distr_samples</span></code> are (mdim, M) <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> and <cite>d_Tree</cite> is
the <code class="xref py py-class docutils literal"><span class="pre">KDTree</span></code> for d_distr_samples</p>
</dd></dl>

<dl class="function">
<dt id="bet.calculateP.simpleFunP.uniform_data">
<code class="descclassname">bet.calculateP.simpleFunP.</code><code class="descname">uniform_data</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.simpleFunP.uniform_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a simple function approximation of <span class="math">\(\rho_{\mathcal{D},M}\)</span>
where <span class="math">\(\rho_{\mathcal{D},M}\)</span> is a uniform probability density over
the entire <code class="docutils literal"><span class="pre">data_domain</span></code>. Here the <code class="docutils literal"><span class="pre">data_domain</span></code> is the union of
voronoi cells defined by <code class="docutils literal"><span class="pre">data</span></code>. In other words we assign each sample the
same probability, so <code class="docutils literal"><span class="pre">M</span> <span class="pre">=</span> <span class="pre">len(data)</span></code> or rather <code class="docutils literal"><span class="pre">len(d_distr_samples)</span> <span class="pre">==</span>
<span class="pre">len(data)</span></code>. The purpose of this method is to approximate uniform
distributions over irregularly shaped domains.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of size (num_samples, mdim)) &#8211; Array containing QoI data where the QoI is mdim diminsional</li>
<li><strong>center_pts_per_edge</strong> (<em>list()</em>) &#8211; number of center points per edge and
additional two points will be added to create the bounding layer</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference external" href="https://docs.python.org/2.7/library/functions.html#tuple" title="(in Python v2.7)">tuple</a></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(rho_D_M, d_distr_samples, d_Tree) where <code class="docutils literal"><span class="pre">rho_D_M</span></code> and
<code class="docutils literal"><span class="pre">d_distr_samples</span></code> are (mdim, M) <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> and <cite>d_Tree</cite>
is the <code class="xref py py-class docutils literal"><span class="pre">KDTree</span></code> for d_distr_samples</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.calculateP.simpleFunP.uniform_hyperrectangle">
<code class="descclassname">bet.calculateP.simpleFunP.</code><code class="descname">uniform_hyperrectangle</code><span class="sig-paren">(</span><em>data</em>, <em>Q_ref</em>, <em>bin_ratio</em>, <em>center_pts_per_edge=1</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.simpleFunP.uniform_hyperrectangle" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a simple function approximation of <span class="math">\(\rho_{\mathcal{D},M}\)</span>
where <span class="math">\(\rho_{\mathcal{D},M}\)</span> is a uniform probability density
centered at Q_ref with bin_ratio of the width
of D.</p>
<p>Since rho_D is a uniform distribution on a hyperrectanlge we should be able
to represent it exactly with <code class="docutils literal"><span class="pre">M</span> <span class="pre">=</span> <span class="pre">3^mdim</span></code> or rather
<code class="docutils literal"><span class="pre">len(d_distr_samples)</span> <span class="pre">==</span> <span class="pre">3^mdim</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>bin_ratio</strong> (<em>double or list()</em>) &#8211; The ratio used to determine the width of the
uniform distributiion as <code class="docutils literal"><span class="pre">bin_size</span> <span class="pre">=</span> <span class="pre">(data_max-data_min)*bin_ratio</span></code></li>
<li><strong>num_d_emulate</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; Number of samples used to emulate using an MC
assumption</li>
<li><strong>data</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of size (num_samples, mdim)) &#8211; Array containing QoI data where the QoI is mdim diminsional</li>
<li><strong>Q_ref</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of size (mdim,)) &#8211; <span class="math">\(Q(\lambda_{reference})\)</span></li>
<li><strong>center_pts_per_edge</strong> (<em>list()</em>) &#8211; number of center points per edge and
additional two points will be added to create the bounding layer</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference external" href="https://docs.python.org/2.7/library/functions.html#tuple" title="(in Python v2.7)">tuple</a></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(rho_D_M, d_distr_samples, d_Tree) where <code class="docutils literal"><span class="pre">rho_D_M</span></code> and
<code class="docutils literal"><span class="pre">d_distr_samples</span></code> are (mdim, M) <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> and <cite>d_Tree</cite>
is the <code class="xref py py-class docutils literal"><span class="pre">KDTree</span></code> for d_distr_samples</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.calculateP.simpleFunP.uniform_hyperrectangle_binsize">
<code class="descclassname">bet.calculateP.simpleFunP.</code><code class="descname">uniform_hyperrectangle_binsize</code><span class="sig-paren">(</span><em>data</em>, <em>Q_ref</em>, <em>bin_size</em>, <em>center_pts_per_edge=1</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.simpleFunP.uniform_hyperrectangle_binsize" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a simple function approximation of <span class="math">\(\rho_{\mathcal{D},M}\)</span>
where <span class="math">\(\rho_{\mathcal{D},M}\)</span> is a uniform probability density
centered at Q_ref with bin_size of the width
of D.</p>
<p>Since rho_D is a uniform distribution on a hyperrectanlge we should be able
to represent it exactly with <code class="docutils literal"><span class="pre">M</span> <span class="pre">=</span> <span class="pre">3^mdim</span></code> or rather
<code class="docutils literal"><span class="pre">len(d_distr_samples)</span> <span class="pre">==</span> <span class="pre">3^mdim</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>bin_size</strong> (<em>double or list()</em>) &#8211; The size used to determine the width of the
uniform distribution</li>
<li><strong>num_d_emulate</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; Number of samples used to emulate using an MC
assumption</li>
<li><strong>data</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of size (num_samples, mdim)) &#8211; Array containing QoI data where the QoI is mdim diminsional</li>
<li><strong>Q_ref</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of size (mdim,)) &#8211; <span class="math">\(Q(\lambda_{reference})\)</span></li>
<li><strong>center_pts_per_edge</strong> (<em>list()</em>) &#8211; number of center points per edge and
additional two points will be added to create the bounding layer</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference external" href="https://docs.python.org/2.7/library/functions.html#tuple" title="(in Python v2.7)">tuple</a></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(rho_D_M, d_distr_samples, d_Tree) where <code class="docutils literal"><span class="pre">rho_D_M</span></code> and
<code class="docutils literal"><span class="pre">d_distr_samples</span></code> are (mdim, M) <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> and <cite>d_Tree</cite>
is the <code class="xref py py-class docutils literal"><span class="pre">KDTree</span></code> for d_distr_samples</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.calculateP.simpleFunP.uniform_hyperrectangle_user">
<code class="descclassname">bet.calculateP.simpleFunP.</code><code class="descname">uniform_hyperrectangle_user</code><span class="sig-paren">(</span><em>data</em>, <em>domain</em>, <em>center_pts_per_edge=1</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.simpleFunP.uniform_hyperrectangle_user" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a simple funciton appoximation of <span class="math">\(\rho_{\mathcal{D},M}\)</span>
where <span class="math">\(\rho{\mathcal{D}, M}\)</span> is a uniform probablity density over the
hyperrectangular domain specified by domain.</p>
<p>Since <span class="math">\(\rho_\mathcal{D}\)</span> is a uniform distribution on a
hyperrectangle we should we able to represent it exactly with
<span class="math">\(M=3^{m}\)</span> where m is the dimension of the data space or rather
<code class="docutils literal"><span class="pre">len(d_distr_samples)</span> <span class="pre">==</span> <span class="pre">3**mdim</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of size (num_samples, mdim)) &#8211; Array containing QoI data where the QoI is mdim diminsional</li>
<li><strong>domain</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> of shape (2, mdim)) &#8211; The domain overwhich <span class="math">\(\rho_\mathcal{D}\)</span> is
uniform.</li>
<li><strong>center_pts_per_edge</strong> (<em>list()</em>) &#8211; number of center points per edge and
additional two points will be added to create the bounding layer</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference external" href="https://docs.python.org/2.7/library/functions.html#tuple" title="(in Python v2.7)">tuple</a></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(rho_D_M, d_distr_samples, d_Tree) where <code class="docutils literal"><span class="pre">rho_D_M</span></code> and
<code class="docutils literal"><span class="pre">d_distr_samples</span></code> are (mdim, M) <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> and <cite>d_Tree</cite>
is the <code class="xref py py-class docutils literal"><span class="pre">KDTree</span></code> for d_distr_samples</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-bet.calculateP.voronoiHistogram">
<span id="bet-calculatep-voronoihistogram-module"></span><h2>bet.calculateP.voronoiHistogram module<a class="headerlink" href="#module-bet.calculateP.voronoiHistogram" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="bet.calculateP.voronoiHistogram.center_and_layer1_points">
<code class="descclassname">bet.calculateP.voronoiHistogram.</code><code class="descname">center_and_layer1_points</code><span class="sig-paren">(</span><em>center_pts_per_edge</em>, <em>center</em>, <em>r_ratio</em>, <em>sur_domain</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.voronoiHistogram.center_and_layer1_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a regular grid of center points that define the voronoi
tesselation of exactly the interior of a hyperrectangle centered at
<code class="docutils literal"><span class="pre">center</span></code> with sides of length <code class="docutils literal"><span class="pre">r_ratio*sur_width</span></code> and the layers
of voronoi cells that bound these interior cells. The resulting voronoi
tesselation exactly represents the hyperrectangle.</p>
<p>This method can also be used to tile <code class="docutils literal"><span class="pre">sur_domain</span></code> with points to define
voronoi regions if the user sets <code class="docutils literal"><span class="pre">r_ratio</span> <span class="pre">=</span> <span class="pre">1</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>center_pts_per_edge</strong> (<em>list()</em>) &#8211; number of center points per edge and
additional two points will be added to create the bounding layer</li>
<li><strong>center</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> of shape (mdim,)) &#8211; location of the center of the hyperrectangle</li>
<li><strong>r_ratio</strong> (<em>double or list()</em>) &#8211; ratio of the length of the sides of the
hyperrectangle to the surrounding domain</li>
<li><strong>sur_domain</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> of shape (mdim, 2)) &#8211; minima and maxima of each dimension defining the
surrounding domain</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference external" href="https://docs.python.org/2.7/library/functions.html#tuple" title="(in Python v2.7)">tuple</a></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(points, interior_and_layer1) where where points is an
<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> of shape (num_points, dim), interior_and_layer1
is a list() of dim :class:<a href="#id1"><span class="problematic" id="id2">`</span></a>numpy.ndarray`s of shape
(center_pts_per_edge+2,).</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.calculateP.voronoiHistogram.center_and_layer1_points_binsize">
<code class="descclassname">bet.calculateP.voronoiHistogram.</code><code class="descname">center_and_layer1_points_binsize</code><span class="sig-paren">(</span><em>center_pts_per_edge</em>, <em>center</em>, <em>r_size</em>, <em>sur_domain</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.voronoiHistogram.center_and_layer1_points_binsize" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a regular grid of center points that define the voronoi
tesselation of exactly the interior of a hyperrectangle centered at
<code class="docutils literal"><span class="pre">center</span></code> with sides of length <code class="docutils literal"><span class="pre">r_size</span></code> and the layers
of voronoi cells that bound these interior cells. The resulting voronoi
tesselation exactly represents the hyperrectangle.</p>
<p>This method can also be used to tile <code class="docutils literal"><span class="pre">sur_domain</span></code> with points to define
voronoi regions if the user sets <code class="docutils literal"><span class="pre">r_ratio</span> <span class="pre">=</span> <span class="pre">1</span></code>. (use binratio)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>center_pts_per_edge</strong> (<em>list()</em>) &#8211; number of center points per edge and
additional two points will be added to create the bounding layer</li>
<li><strong>center</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> of shape (mdim,)) &#8211; location of the center of the hyperrectangle</li>
<li><strong>r_size</strong> (<em>double or list()</em>) &#8211; size of the length of the sides of the
hyperrectangle to the surrounding domain</li>
<li><strong>sur_domain</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> of shape (mdim, 2)) &#8211; minima and maxima of each dimension defining the
surrounding domain</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference external" href="https://docs.python.org/2.7/library/functions.html#tuple" title="(in Python v2.7)">tuple</a></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(points, interior_and_layer1) where where points is an
<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> of shape (num_points, dim), interior_and_layer1
is a list() of dim :class:<a href="#id3"><span class="problematic" id="id4">`</span></a>numpy.ndarray`s of shape
(center_pts_per_edge+2,).</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.calculateP.voronoiHistogram.edges_from_points">
<code class="descclassname">bet.calculateP.voronoiHistogram.</code><code class="descname">edges_from_points</code><span class="sig-paren">(</span><em>points</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.voronoiHistogram.edges_from_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a sequence of arrays describing the voronoi points in each dimension
that define a set of bounded hyperrectangular bins returns the edges of bins
formed by voronoi cells along each dimensions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>points</strong> (list of dim :class:<a href="#id5"><span class="problematic" id="id6">`</span></a>numpy.ndarray`s of shape (nbins+2,)) &#8211; the coordindates of voronoi points that would generate
these bins in each dimensions</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">edges, A sequence of arrays describing the edges of bins along
each dimension.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Rtype edges:</th><td class="field-body">A list() containing mdim :class:<a href="#id7"><span class="problematic" id="id8">`</span></a>numpy.ndarray`s of shape
(nbins_per_dim+1,)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.calculateP.voronoiHistogram.edges_regular">
<code class="descclassname">bet.calculateP.voronoiHistogram.</code><code class="descname">edges_regular</code><span class="sig-paren">(</span><em>center_pts_per_edge</em>, <em>center</em>, <em>r_ratio</em>, <em>sur_domain</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.voronoiHistogram.edges_regular" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a sequence of arrays describing the edges of the finite voronoi
cells in each direction. The voronoi tesselation is defined by regular grid
of center points that define the voronoi tesselation of exactly the
interior of a hyperrectangle centered at <code class="docutils literal"><span class="pre">center</span></code> with sides of length
<code class="docutils literal"><span class="pre">r_ratio*sur_width</span></code> and the layers of voronoi cells that bound these
interior cells. The resulting voronoi tesselation exactly represents the
hyperrectangle. The bounding voronoi cells are made finite by bounding them
with an  additional layer to represent <code class="docutils literal"><span class="pre">sur_domain</span></code>.</p>
<p>This method can also be used to tile <code class="docutils literal"><span class="pre">sur_domain</span></code> with points to define
voronoi regions if the user sets <code class="docutils literal"><span class="pre">r_ratio</span> <span class="pre">=</span> <span class="pre">1</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>center_pts_per_edge</strong> (<em>list()</em>) &#8211; number of center points per edge and
additional two points will be added to create the bounding layer</li>
<li><strong>center</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> of shape (mdim,)) &#8211; location of the center of the hyperrectangle</li>
<li><strong>r_ratio</strong> (<em>double or list()</em>) &#8211; ratio of the length of the sides of the
hyperrectangle to the surrounding domain</li>
<li><strong>sur_domain</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> of shape (mdim, 2)) &#8211; minima and maxima of each dimension defining the
surrounding domain</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference external" href="https://docs.python.org/2.7/library/functions.html#tuple" title="(in Python v2.7)">tuple</a></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(points, interior_and_layer1, interior_and_doublelayer) where
where points is an <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> of shape (num_points, dim),
interior_and_layer1 and interior_and_layer2 are lists of dim
:class:<a href="#id9"><span class="problematic" id="id10">`</span></a>numpy.ndarray`s of shape (center_pts_per_edge+2,) and
(center_pts_per_edge+4,) respectively.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.calculateP.voronoiHistogram.edges_regular_binsize">
<code class="descclassname">bet.calculateP.voronoiHistogram.</code><code class="descname">edges_regular_binsize</code><span class="sig-paren">(</span><em>center_pts_per_edge</em>, <em>center</em>, <em>r_size</em>, <em>sur_domain</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.voronoiHistogram.edges_regular_binsize" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a sequence of arrays describing the edges of the finite voronoi
cells in each direction. The voronoi tesselation is defined by regular grid
of center points that define the voronoi tesselation of exactly the
interior of a hyperrectangle centered at <code class="docutils literal"><span class="pre">center</span></code> with sides of length
<code class="docutils literal"><span class="pre">r_size</span></code> and the layers of voronoi cells that bound these
interior cells. The resulting voronoi tesselation exactly represents the
hyperrectangle. The bounding voronoi cells are made finite by bounding them
with an  additional layer to represent <code class="docutils literal"><span class="pre">sur_domain</span></code>.</p>
<p>This method can also be used to tile <code class="docutils literal"><span class="pre">sur_domain</span></code> with points to define
voronoi regions if the user sets <code class="docutils literal"><span class="pre">r_ratio</span> <span class="pre">=</span> <span class="pre">1</span></code>. use binratio below</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>center_pts_per_edge</strong> (<em>list()</em>) &#8211; number of center points per edge and
additional two points will be added to create the bounding layer</li>
<li><strong>center</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> of shape (mdim,)) &#8211; location of the center of the hyperrectangle</li>
<li><strong>r_size</strong> (<em>double or list()</em>) &#8211; size of the length of the sides of the
hyperrectangle to the surrounding domain</li>
<li><strong>sur_domain</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> of shape (mdim, 2)) &#8211; minima and maxima of each dimension defining the
surrounding domain</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference external" href="https://docs.python.org/2.7/library/functions.html#tuple" title="(in Python v2.7)">tuple</a></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(points, interior_and_layer1, interior_and_doublelayer) where
where points is an <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> of shape (num_points, dim),
interior_and_layer1 and interior_and_layer2 are lists of dim
:class:<a href="#id11"><span class="problematic" id="id12">`</span></a>numpy.ndarray`s of shape (center_pts_per_edge+2,) and
(center_pts_per_edge+4,) respectively.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.calculateP.voronoiHistogram.histogramdd_volumes">
<code class="descclassname">bet.calculateP.voronoiHistogram.</code><code class="descname">histogramdd_volumes</code><span class="sig-paren">(</span><em>edges</em>, <em>points</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.voronoiHistogram.histogramdd_volumes" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a sequence of arrays describing the edges of voronoi cells (bins)
along each dimension and an &#8216;ij&#8217; ordered sequence of points (1 per voronoi
cell) returns a list of the volumes associated with these voronoic cells.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>edges</strong> &#8211; </li>
<li><strong>points</strong> (<code class="xref py py-class docutils literal"><span class="pre">numpy.ndarrray</span></code> of shape (num_points, mdim)) &#8211; points used to define the voronoi tesselation (only the
points that define regions of finite volumes)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">finite volumes associated with <code class="docutils literal"><span class="pre">points</span></code></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> of shape (len(points),)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.calculateP.voronoiHistogram.points_from_edges">
<code class="descclassname">bet.calculateP.voronoiHistogram.</code><code class="descname">points_from_edges</code><span class="sig-paren">(</span><em>edges</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.voronoiHistogram.points_from_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a sequence of arrays describing the edges of bins formed by voronoi
cells along each dimensions returns the voronoi points that would generate
these cells.</p>
<dl class="docutils">
<dt>..todo:: This method only creates points in the center of the bins. Needs</dt>
<dd>Needs to be adjusted so that it creates points in the voronoi cell
locations.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>edges</strong> (A list() containing mdim :class:<a href="#id13"><span class="problematic" id="id14">`</span></a>numpy.ndarray`s of shape
(nbins_per_dim+1,)) &#8211; A sequence of arrays describing the edges of bins along each
dimension.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">points, the coordindates of voronoi points that would generate
these bins</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> of shape (num_points, dim) where num_points
= product(nbins_per_dim)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.calculateP.voronoiHistogram.simple_fun_uniform">
<code class="descclassname">bet.calculateP.voronoiHistogram.</code><code class="descname">simple_fun_uniform</code><span class="sig-paren">(</span><em>points</em>, <em>volumes</em>, <em>rect_domain</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.calculateP.voronoiHistogram.simple_fun_uniform" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a set of points, the volumes associated with these points, and
<code class="docutils literal"><span class="pre">rect_domain</span></code> creates a simple function approximation of a uniform
distribution over the hyperrectangle defined by <code class="docutils literal"><span class="pre">rect_domain</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>points</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> of shape (num_points,)) &#8211; points used to define the voronoi tesselation (only the
points that define regions of finite volumes)</li>
<li><strong>volumes</strong> (<em>list()</em>) &#8211; finite volumes associated with <code class="docutils literal"><span class="pre">points</span></code></li>
<li><strong>rect_domain</strong> (<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> of shape (mdim, 2)) &#8211; minima and maxima of each dimension defining the
hyperrectangle of uniform probability</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference external" href="https://docs.python.org/2.7/library/functions.html#tuple" title="(in Python v2.7)">tuple</a></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(rho_D_M, points, d_Tree) where <code class="docutils literal"><span class="pre">rho_D_M</span></code> and
<code class="docutils literal"><span class="pre">points</span></code> are (mdim, M) <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> and
<cite>d_Tree</cite> is the <code class="xref py py-class docutils literal"><span class="pre">KDTree</span></code> for points</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-bet.calculateP">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-bet.calculateP" title="Permalink to this headline">¶</a></h2>
<p>This subpackage provides classes and methods for calulating the probability
measure <span class="math">\(P_{\Lambda}\)</span>.</p>
<ul>
<li><dl class="first docutils">
<dt><a class="reference internal" href="#module-bet.calculateP.calculateP" title="bet.calculateP.calculateP"><code class="xref py py-mod docutils literal"><span class="pre">calculateP</span></code></a> provides methods for approximating probability</dt>
<dd><p class="first last">densities</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><a class="reference internal" href="#module-bet.calculateP.simpleFunP" title="bet.calculateP.simpleFunP"><code class="xref py py-mod docutils literal"><span class="pre">simpleFunP</span></code></a> provides methods for creating simple function</dt>
<dd><p class="first last">approximations of probability densisties</p>
</dd>
</dl>
</li>
</ul>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">bet.calculateP package</a><ul>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-bet.calculateP.calculateP">bet.calculateP.calculateP module</a></li>
<li><a class="reference internal" href="#module-bet.calculateP.simpleFunP">bet.calculateP.simpleFunP module</a></li>
<li><a class="reference internal" href="#module-bet.calculateP.voronoiHistogram">bet.calculateP.voronoiHistogram module</a></li>
<li><a class="reference internal" href="#module-bet.calculateP">Module contents</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/bet.calculateP.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2014, Lindley Graham, Steven Mattis, Troy Butler.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.3.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.3</a>
      
      |
      <a href="_sources/bet.calculateP.txt"
          rel="nofollow">Page source</a></li>
    </div>

    

    
  </body>
</html>