"""
k = dsearchn(X,T,XI) returns the indices k of the closest points in X for each
point in XI. X is an m-by-n matrix representing m points in n-dimensional
space. XI is a p-by-n matrix, representing p points in n-dimensional space. T
is a numt-by-n+1 matrix, a triangulation of the data X generated by delaunayn.
The output k is a column vector of length p. 

k = dsearchn(X,XI) performs the search without using a triangulation. With
large X and small XI, this approach is faster and uses much less memory.

[k,d] = dsearchn(X,...) also returns the distances d to the closest points. d
is a column vector of length p. 

"""
from scipy.spatial import Delaunay

def desearchn(X, XI, type='tess'):
    """
    k = dsearchn(X,XI, tri) returns the indices k of the closest points in X for
    each point in XI. X is an m-by-n matrix representing m points in
    n-dimensional space. XI is a p-by-n matrix, representing p points in
    n-dimensional space. ``tri`` is a numt-by-n+1 matrix, a triangulation of the data
    X generated by delaunayn.  The output k is a column vector of length p. 

    :param string type: If ``tess`` performs the search using a
    Delaunay tesselation. If ``tree`` performs the search using a KDTree.

    :rtype: :class:`~numpy.ndarray` of shape (p,)
    :returns: (``k``, tess or tree)

    """
    if create_tri:

