

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>bet.sensitivity package &mdash; BET 1.0.2 documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic|Roboto+Slab:400,700|Inconsolata:400,700&subset=latin,cyrillic' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="BET 1.0.2 documentation" href="index.html"/>
        <link rel="up" title="bet package" href="bet.html"/>
        <link rel="next" title="Todo List" href="todo_list.html"/>
        <link rel="prev" title="bet.sampling package" href="bet.sampling.html"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        
          <a href="index.html" class="fa fa-home"> BET</a>
        
        
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
          
          
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="overview.html">Overview</a><ul>
<li class="toctree-l2"><a class="reference internal" href="overview.html#installation">Installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="overview.html#package-layout">Package Layout</a></li>
<li class="toctree-l2"><a class="reference internal" href="overview.html#code-overview">Code Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="overview.html#internal-dependencies">Internal dependencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="overview.html#external-dependencies">External dependencies</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="parallel.html">Parallel</a><ul>
<li class="toctree-l2"><a class="reference internal" href="parallel.html#installation">Installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel.html#running-in-parallel">Running in parallel</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallel.html#parallel-enabled-modules">Parallel Enabled Modules</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="examples/examples_overview.html">Some References and Examples</a><ul>
<li class="toctree-l2"><a class="reference internal" href="examples/examples_overview.html#validation-example">Validation example</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples/examples_overview.html#linear-map-example">Linear Map Example</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples/examples_overview.html#non-linear-map-example">Non-Linear Map Example</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples/examples_overview.html#adcirc-based-examples">ADCIRC Based Examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples/examples_overview.html#contaminant-transport-example">Contaminant Transport Example:</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples/examples_overview.html#choosing-optimal-qois-examples">Choosing Optimal QoIs Examples:</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples/examples_overview.html#list-of-all-examples">List of all examples</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="modules.html">bet</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="bet.html">bet package</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="todo_list.html">Todo List</a></li>
</ul>

          
        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">BET</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
          <li><a href="modules.html">bet</a> &raquo;</li>
      
          <li><a href="bet.html">bet package</a> &raquo;</li>
      
    <li>bet.sensitivity package</li>
      <li class="wy-breadcrumbs-aside">
        
          <a href="_sources/bet.sensitivity.txt" rel="nofollow"> View page source</a>
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <div class="section" id="bet-sensitivity-package">
<h1>bet.sensitivity package<a class="headerlink" href="#bet-sensitivity-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-bet.sensitivity.chooseQoIs">
<span id="bet-sensitivity-chooseqois-module"></span><h2>bet.sensitivity.chooseQoIs module<a class="headerlink" href="#module-bet.sensitivity.chooseQoIs" title="Permalink to this headline">¶</a></h2>
<p>This module contains functions choosing optimal QoIs to use in the stochastic
inverse problem.</p>
<dl class="function">
<dt id="bet.sensitivity.chooseQoIs.calculate_avg_condnum">
<code class="descclassname">bet.sensitivity.chooseQoIs.</code><code class="descname">calculate_avg_condnum</code><span class="sig-paren">(</span><em>grad_tensor</em>, <em>qoi_set</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.sensitivity.chooseQoIs.calculate_avg_condnum" title="Permalink to this definition">¶</a></dt>
<dd><p>Given gradient vectors at some points (centers) in the parameter space and
given a specific set of QoIs, caculate the average condition number of the
matrices formed by the gradient vectors of each QoI map at each center.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>grad_tensor</strong> (<code class="xref py py-class docutils literal"><span class="pre">np.ndarray</span></code> of shape (num_centers, num_qois,
Lambda_dim) where num_centers is the number of points in <span class="math">\(\Lambda\)</span>
we have approximated the gradient vectors and num_qois is the number of
QoIs we are given.) &#8211; Gradient vectors at each center in the parameter space
<span class="math">\(\Lambda\)</span> for each QoI map.</li>
<li><strong>qoi_set</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#list" title="(in Python v2.7)"><em>list</em></a>) &#8211; List of QoI indices</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference external" href="https://docs.python.org/2.7/library/functions.html#tuple" title="(in Python v2.7)">tuple</a></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(condnum, singvals) where condnum is a float and singvals
has shape (num_centers, Data_dim)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.sensitivity.chooseQoIs.calculate_avg_volume">
<code class="descclassname">bet.sensitivity.chooseQoIs.</code><code class="descname">calculate_avg_volume</code><span class="sig-paren">(</span><em>grad_tensor</em>, <em>qoi_set</em>, <em>bin_volume=None</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.sensitivity.chooseQoIs.calculate_avg_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>If you are using <code class="docutils literal"><span class="pre">bin_ratio</span></code> to define the hyperrectangle in the Data
space you must must give this method gradient vectors normalized with
respect to the 1-norm.  If you are using <code class="docutils literal"><span class="pre">bin_size</span></code> to define the
hyperrectangle in the Data space you must give this method the original
gradient vectors. If you also give a <code class="docutils literal"><span class="pre">bin_volume</span></code>, this method will
approximate the volume of the region of non-zero probability in the inverse
solution.
Given gradient vectors at some points (centers) in the parameter space
and given a specific set of QoIs, calculate the average volume of the 
inverse image of a box in the data space assuming the mapping is linear near
each center.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>grad_tensor</strong> (<code class="xref py py-class docutils literal"><span class="pre">np.ndarray</span></code> of shape (num_centers, num_qois,
Lambda_dim) where num_centers is the number of points in <span class="math">\(\Lambda\)</span>
we have approximated the gradient vectors and num_qois is the number of
QoIs we are given.) &#8211; Gradient vectors at each point of interest in the
parameter space <span class="math">\(\Lambda\)</span> for each QoI map.</li>
<li><strong>qoi_set</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#list" title="(in Python v2.7)"><em>list</em></a>) &#8211; List of QoI indices</li>
<li><strong>bin_volume</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; The volume of the Data_dim hyperrectangle to
invert into <span class="math">\(\Lambda\)</span></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference external" href="https://docs.python.org/2.7/library/functions.html#tuple" title="(in Python v2.7)">tuple</a></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(avg_volume, singvals) where avg_volume is a float and singvals
has shape (num_centers, Data_dim)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.sensitivity.chooseQoIs.chooseOptQoIs">
<code class="descclassname">bet.sensitivity.chooseQoIs.</code><code class="descname">chooseOptQoIs</code><span class="sig-paren">(</span><em>grad_tensor</em>, <em>qoiIndices=None</em>, <em>num_qois_return=None</em>, <em>num_optsets_return=None</em>, <em>inner_prod_tol=1.0</em>, <em>volume=False</em>, <em>remove_zeros=True</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.sensitivity.chooseQoIs.chooseOptQoIs" title="Permalink to this definition">¶</a></dt>
<dd><p>Given gradient vectors at some points (centers) in the parameter space, a
set of QoIs to choose from, and the number of desired QoIs to return, this
method returns the <code class="docutils literal"><span class="pre">num_optsets_return</span></code> best sets of QoIs with with
repsect to either the average condition number of the matrix formed by the
gradient vectors of each QoI map, or the average volume of the inverse
problem us this set of QoIs, computed as the product of the singular values
of the same matrix.  This method is brute force, i.e., if the method is
given 10,000 QoIs and told to return the N best sets of 3, it will check all
10,000 choose 3 possible sets.  See chooseOptQoIs_large for a less
computationally expensive approach.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>grad_tensor</strong> (<code class="xref py py-class docutils literal"><span class="pre">np.ndarray</span></code> of shape (num_centers, num_qois,
Lambda_dim) where num_centers is the number of points in <span class="math">\(\Lambda\)</span>
we have approximated the gradient vectors and num_qois is the total
number of possible QoIs to choose from) &#8211; Gradient vectors at each point of interest in the
parameter space <span class="math">\(\Lambda\)</span> for each QoI map.</li>
<li><strong>qoiIndices</strong> (<code class="xref py py-class docutils literal"><span class="pre">np.ndarray</span></code> of size (1, num QoIs to consider)) &#8211; Set of QoIs to consider from grad_tensor.  Default is
range(0, grad_tensor.shape[1])</li>
<li><strong>num_qois_return</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; Number of desired QoIs to use in the
inverse problem.  Default is Lambda_dim</li>
<li><strong>num_optsets_return</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; Number of best sets to return
Default is 10</li>
<li><strong>volume</strong> (<em>boolean</em>) &#8211; If measure is True, use <code class="docutils literal"><span class="pre">calculate_avg_volume</span></code>
to determine optimal QoIs</li>
<li><strong>remove_zeros</strong> (<em>boolean</em>) &#8211; If True, <code class="docutils literal"><span class="pre">find_unique_vecs</span></code> will remove any
QoIs that have a zero gradient vector at atleast one point in
<span class="math">\(\Lambda\)</span>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><cite>np.ndarray</cite> of shape (num_optsets_returned, num_qois_returned + 1)</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">condnum_indices_mat</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.sensitivity.chooseQoIs.chooseOptQoIs_large">
<code class="descclassname">bet.sensitivity.chooseQoIs.</code><code class="descname">chooseOptQoIs_large</code><span class="sig-paren">(</span><em>grad_tensor</em>, <em>qoiIndices=None</em>, <em>max_qois_return=None</em>, <em>num_optsets_return=None</em>, <em>inner_prod_tol=None</em>, <em>cond_tol=None</em>, <em>volume=False</em>, <em>remove_zeros=True</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.sensitivity.chooseQoIs.chooseOptQoIs_large" title="Permalink to this definition">¶</a></dt>
<dd><p>Given gradient vectors at some points (centers) in the parameter space, a
large set of QoIs to choose from, and the number of desired QoIs to return,
this method return the set of optimal QoIs of size 2, 3, ... max_qois_return
to use in the inverse problem by choosing the sets with the smallext average
condition number or volume.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>grad_tensor</strong> (<code class="xref py py-class docutils literal"><span class="pre">np.ndarray</span></code> of shape (num_centers, num_qois,
Lambda_dim) where num_centers is the number of points in <span class="math">\(\Lambda\)</span>
we have approximated the gradient vectors and num_qois is the total
number of possible QoIs to choose from) &#8211; Gradient vectors at each point of interest in the
parameter space <span class="math">\(\Lambda\)</span> for each QoI map.</li>
<li><strong>qoiIndices</strong> (<code class="xref py py-class docutils literal"><span class="pre">np.ndarray</span></code> of size (1, num QoIs to consider)) &#8211; Set of QoIs to consider from grad_tensor.  Default is
range(0, grad_tensor.shape[1])</li>
<li><strong>max_qois_return</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; Maximum number of desired QoIs to use in the
inverse problem.  Default is Lambda_dim</li>
<li><strong>num_optsets_return</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; Number of best sets to return
Default is 10</li>
<li><strong>inner_prod_tol</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; Maximum acceptable average inner product
between two QoI maps.</li>
<li><strong>cond_tol</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; Throw out all sets of QoIs with average condition
number greater than this.</li>
<li><strong>volume</strong> (<em>boolean</em>) &#8211; If volume is True, use <code class="docutils literal"><span class="pre">calculate_avg_volume</span></code>
to determine optimal QoIs</li>
<li><strong>remove_zeros</strong> (<em>boolean</em>) &#8211; If True, <code class="docutils literal"><span class="pre">find_unique_vecs</span></code> will remove any
QoIs that have a zero gradient vector at atleast one point in
<span class="math">\(\Lambda\)</span>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference external" href="https://docs.python.org/2.7/library/functions.html#tuple" title="(in Python v2.7)">tuple</a></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(condnum_indices_mat, optsingvals) where condnum_indices_mat has
shape (num_optsets_return, num_qois_return+1) and optsingvals
has shape (num_centers, num_qois_return, num_optsets_return)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.sensitivity.chooseQoIs.chooseOptQoIs_large_verbose">
<code class="descclassname">bet.sensitivity.chooseQoIs.</code><code class="descname">chooseOptQoIs_large_verbose</code><span class="sig-paren">(</span><em>grad_tensor</em>, <em>qoiIndices=None</em>, <em>max_qois_return=None</em>, <em>num_optsets_return=None</em>, <em>inner_prod_tol=None</em>, <em>cond_tol=None</em>, <em>volume=False</em>, <em>remove_zeros=True</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.sensitivity.chooseQoIs.chooseOptQoIs_large_verbose" title="Permalink to this definition">¶</a></dt>
<dd><p>Given gradient vectors at some points (centers) in the parameter space, a
large set of QoIs to choose from, and the number of desired QoIs to return,
this method return the set of optimal QoIs of size 1, 2, ... max_qois_return
to use in the inverse problem by choosing the set with smallext average
condition number.  Also a tensor that represents the singular values of the
matrices formed by the gradient vectors of the optimal QoIs at each center
is returned.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>grad_tensor</strong> (<code class="xref py py-class docutils literal"><span class="pre">np.ndarray</span></code> of shape (num_centers, num_qois,
Lambda_dim) where num_centers is the number of points in <span class="math">\(\Lambda\)</span>
we have approximated the gradient vectors and num_qois is the total
number of possible QoIs to choose from.) &#8211; Gradient vectors at each point of interest in the
parameter space <span class="math">\(\Lambda\)</span> for each QoI map.</li>
<li><strong>qoiIndices</strong> (<code class="xref py py-class docutils literal"><span class="pre">np.ndarray</span></code> of size (1, num QoIs to consider)) &#8211; Set of QoIs to consider from grad_tensor.  Default is
range(0, grad_tensor.shape[1]).</li>
<li><strong>max_qois_return</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; Maximum number of desired QoIs to use in the
inverse problem.  Default is Lambda_dim.</li>
<li><strong>num_optsets_return</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; Number of best sets to return.  Default is
10.</li>
<li><strong>inner_prod_tol</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; Throw out one vectors from each pair of
QoIs that has average inner product greater than this.  Default is 0.9.</li>
<li><strong>cond_tol</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; Throw out all sets of QoIs with average condition
number greater than this.  Default is max_float.</li>
<li><strong>volume</strong> (<em>boolean</em>) &#8211; If volume is True, use <code class="docutils literal"><span class="pre">calculate_avg_volume</span></code>
to determine optimal QoIs</li>
<li><strong>remove_zeros</strong> (<em>boolean</em>) &#8211; If True, <code class="docutils literal"><span class="pre">find_unique_vecs</span></code> will remove any
QoIs that have a zero gradient vector at atleast one point in
<span class="math">\(\Lambda\)</span>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference external" href="https://docs.python.org/2.7/library/functions.html#tuple" title="(in Python v2.7)">tuple</a></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(condnum_indices_mat, optsingvals) where condnum_indices_mat has
shape (num_optsets_return, num_qois_return+1) and optsingvals is a list
where each element has shape (num_centers, num_qois_return,
num_optsets_return).  num_qois_return will change for each element of
the list.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.sensitivity.chooseQoIs.chooseOptQoIs_verbose">
<code class="descclassname">bet.sensitivity.chooseQoIs.</code><code class="descname">chooseOptQoIs_verbose</code><span class="sig-paren">(</span><em>grad_tensor</em>, <em>qoiIndices=None</em>, <em>num_qois_return=None</em>, <em>num_optsets_return=None</em>, <em>inner_prod_tol=1.0</em>, <em>volume=False</em>, <em>remove_zeros=True</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.sensitivity.chooseQoIs.chooseOptQoIs_verbose" title="Permalink to this definition">¶</a></dt>
<dd><p>Given gradient vectors at some points (centers) in the parameter space, a
set of QoIs to choose from, and the number of desired QoIs to return, this
method returns the <code class="docutils literal"><span class="pre">num_optsets_return</span></code> best sets of QoIs with with
repsect to either the average condition number of the matrix formed by the
gradient vectors of each QoI map, or the average volume of the inverse
problem us this set of QoIs, computed as the product of the singular values
of the same matrix.  This method is brute force, i.e., if the method is
given 10,000 QoIs and told to return the N best sets of 3, it will check all
10,000 choose 3 possible sets.  See chooseOptQoIs_large for a less
computationally expensive approach.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>grad_tensor</strong> (<code class="xref py py-class docutils literal"><span class="pre">np.ndarray</span></code> of shape (num_centers, num_qois,
Lambda_dim) where num_centers is the number of points in <span class="math">\(\Lambda\)</span>
we have approximated the gradient vectors and num_qois is the total
number of possible QoIs to choose from) &#8211; Gradient vectors at each point of interest in the
parameter space <span class="math">\(\Lambda\)</span> for each QoI map.</li>
<li><strong>qoiIndices</strong> (<code class="xref py py-class docutils literal"><span class="pre">np.ndarray</span></code> of size (1, num QoIs to consider)) &#8211; Set of QoIs to consider from grad_tensor.  Default is
range(0, grad_tensor.shape[1])</li>
<li><strong>num_qois_return</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; Number of desired QoIs to use in the
inverse problem.  Default is Lambda_dim</li>
<li><strong>num_optsets_return</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; Number of best sets to return
Default is 10</li>
<li><strong>volume</strong> (<em>boolean</em>) &#8211; If volume is True, use <code class="docutils literal"><span class="pre">calculate_avg_volume</span></code>
to determine optimal QoIs</li>
<li><strong>remove_zeros</strong> (<em>boolean</em>) &#8211; If True, <code class="docutils literal"><span class="pre">find_unique_vecs</span></code> will remove any
QoIs that have a zero gradient vector at atleast one point in
<span class="math">\(\Lambda\)</span>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference external" href="https://docs.python.org/2.7/library/functions.html#tuple" title="(in Python v2.7)">tuple</a></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(condnum_indices_mat, optsingvals) where condnum_indices_mat has
shape (num_optsets_return, num_qois_return+1) and optsingvals
has shape (num_centers, num_qois_return, num_optsets_return)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.sensitivity.chooseQoIs.find_good_sets">
<code class="descclassname">bet.sensitivity.chooseQoIs.</code><code class="descname">find_good_sets</code><span class="sig-paren">(</span><em>grad_tensor</em>, <em>good_sets_prev</em>, <em>unique_indices</em>, <em>num_optsets_return</em>, <em>cond_tol</em>, <em>volume</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.sensitivity.chooseQoIs.find_good_sets" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<p class="last">Use the idea we only know vectors are with 10% accuracy to guide
inner_prod tol and condnum_tol.</p>
</div>
<p>Given gradient vectors at each center in the parameter space and given
good sets of size n - 1, return good sets of size n.  That is, return
sets of size n that have average condition number less than some tolerance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>grad_tensor</strong> (<code class="xref py py-class docutils literal"><span class="pre">np.ndarray</span></code> of shape (num_centers,num_qois,Ldim)
where num_centers is the number of points in :math:&#8217;Lambda&#8217; we have
approximated the gradient vectors, num_qois is the total number of
possible QoIs to choose from, Ldim is the dimension of <span class="math">\(\Lambda\)</span>.) &#8211; Gradient vectors at each centers in the parameter
space <span class="math">\(\Lambda\)</span> for each QoI map.</li>
<li><strong>good_sets_prev</strong> (<code class="xref py py-class docutils literal"><span class="pre">np.ndarray</span></code> of size (num_good_sets_prev, n -
1)) &#8211; Good sets of QoIs of size n - 1.</li>
<li><strong>unique_indices</strong> (<code class="xref py py-class docutils literal"><span class="pre">np.ndarray</span></code> of size (num_unique_qois, 1)) &#8211; Unique QoIs to consider.</li>
<li><strong>num_optsets_return</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; Number of best sets to return</li>
<li><strong>cond_tol</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; Throw out all sets of QoIs with average condition
number greater than this.</li>
<li><strong>volume</strong> (<em>boolean</em>) &#8211; If volume is True, use <code class="docutils literal"><span class="pre">calculate_avg_volume</span></code>
to determine optimal QoIs</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference external" href="https://docs.python.org/2.7/library/functions.html#tuple" title="(in Python v2.7)">tuple</a></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(good_sets, best_sets, optsingvals_tensor) where good sets has
size (num_good_sets, n), best sets has size (num_optsets_return,
n + 1) and optsingvals_tensor has size (num_centers, n, Lambda_dim)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.sensitivity.chooseQoIs.find_unique_vecs">
<code class="descclassname">bet.sensitivity.chooseQoIs.</code><code class="descname">find_unique_vecs</code><span class="sig-paren">(</span><em>grad_tensor</em>, <em>inner_prod_tol</em>, <em>qoiIndices=None</em>, <em>remove_zeros=True</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.sensitivity.chooseQoIs.find_unique_vecs" title="Permalink to this definition">¶</a></dt>
<dd><p>Given gradient vectors at each center in the parameter space, sort throught
them and remove any QoI that has a zero vector at any center, then remove
one from any pair of QoIs that have an average inner product greater than
some tolerance, i.e., an average angle between the two vectors smaller than
some tolerance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>grad_tensor</strong> (<code class="xref py py-class docutils literal"><span class="pre">np.ndarray</span></code> of shape (num_centers,num_qois,Ldim)
where num_centers is the number of points in :math:&#8217;Lambda&#8217; we have
approximated the gradient vectors, num_qois is the total number of
possible QoIs to choose from, Ldim is the dimension of <span class="math">\(\Lambda\)</span>.) &#8211; Gradient vectors at each point of interest in the
parameter space :math:&#8217;Lambda&#8217; for each QoI map.</li>
<li><strong>inner_prod_tol</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; Maximum acceptable average inner product
between two QoI maps.</li>
<li><strong>qoiIndices</strong> (:class:&#8217;<cite>np.ndarray</cite> of size (1, num QoIs to consider)) &#8211; Set of QoIs to consider.</li>
<li><strong>remove_zeros</strong> (<em>boolean</em>) &#8211; If True, <code class="docutils literal"><span class="pre">find_unique_vecs</span></code> will remove any
QoIs that have a zero gradient vector at atleast one point in
<span class="math">\(\Lambda\)</span>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><cite>np.ndarray</cite> of shape (num_unique_vecs, 1)</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">unique_vecs</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-bet.sensitivity.gradients">
<span id="bet-sensitivity-gradients-module"></span><h2>bet.sensitivity.gradients module<a class="headerlink" href="#module-bet.sensitivity.gradients" title="Permalink to this headline">¶</a></h2>
<p>This module contains functions for approximating gradient vectors of QoI maps.
All methods that cluster points around centers are written to return the samples
in the following order : CENTERS, FOLLOWED BY THE CLUSTER AROUND THE FIRST
CENTER, THEN THE CLUSTER AROUND THE SECOND CENTER AND SO ON.</p>
<dl class="function">
<dt id="bet.sensitivity.gradients.calculate_gradients_cfd">
<code class="descclassname">bet.sensitivity.gradients.</code><code class="descname">calculate_gradients_cfd</code><span class="sig-paren">(</span><em>samples</em>, <em>data</em>, <em>normalize=True</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.sensitivity.gradients.calculate_gradients_cfd" title="Permalink to this definition">¶</a></dt>
<dd><p>Approximate gradient vectors at <code class="docutils literal"><span class="pre">num_centers,</span> <span class="pre">centers.shape[0]</span></code> points
in the parameter space for each QoI map.  THIS METHOD IS DEPENDENT
ON USING :meth:~bet.sensitivity.pick_cfd_points TO CHOOSE SAMPLES FOR THE 
CFD STENCIL AROUND EACH CENTER.  THE ORDERING MATTERS.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>samples</strong> (<code class="xref py py-class docutils literal"><span class="pre">np.ndarray</span></code> of shape
(2*Lambda_dim*num_centers, Lambda_dim)) &#8211; Samples for which the model has been solved.</li>
<li><strong>data</strong> (<code class="xref py py-class docutils literal"><span class="pre">np.ndarray</span></code> of shape (num_samples, Data_dim)) &#8211; QoI values corresponding to each sample.</li>
<li><strong>normalize</strong> (<em>boolean</em>) &#8211; If normalize is True, normalize each gradient
vector</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><code class="xref py py-class docutils literal"><span class="pre">np.ndarray</span></code> of shape (num_samples, Data_dim, Lambda_dim)</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Tensor representation of the gradient vectors of each
QoI map at each point in centers</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.sensitivity.gradients.calculate_gradients_ffd">
<code class="descclassname">bet.sensitivity.gradients.</code><code class="descname">calculate_gradients_ffd</code><span class="sig-paren">(</span><em>samples</em>, <em>data</em>, <em>normalize=True</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.sensitivity.gradients.calculate_gradients_ffd" title="Permalink to this definition">¶</a></dt>
<dd><p>Approximate gradient vectors at <code class="docutils literal"><span class="pre">num_centers,</span> <span class="pre">centers.shape[0]</span></code> points
in the parameter space for each QoI map.  THIS METHOD IS DEPENDENT ON USING
:meth:~bet.sensitivity.gradients.pick_ffd_points TO CHOOSE SAMPLES FOR THE
FFD STENCIL AROUND EACH CENTER. THE ORDERING MATTERS.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>samples</strong> (<code class="xref py py-class docutils literal"><span class="pre">np.ndarray</span></code> of shape (num_samples, Lambda_dim)) &#8211; Samples for which the model has been solved.</li>
<li><strong>data</strong> (<code class="xref py py-class docutils literal"><span class="pre">np.ndarray</span></code> of shape (num_samples, Data_dim)) &#8211; QoI values corresponding to each sample.</li>
<li><strong>normalize</strong> (<em>boolean</em>) &#8211; If normalize is True, normalize each gradient
vector</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><code class="xref py py-class docutils literal"><span class="pre">np.ndarray</span></code> of shape (num_samples, Data_dim, Lambda_dim)</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Tensor representation of the gradient vectors of each
QoI map at each point in centers</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.sensitivity.gradients.calculate_gradients_rbf">
<code class="descclassname">bet.sensitivity.gradients.</code><code class="descname">calculate_gradients_rbf</code><span class="sig-paren">(</span><em>samples</em>, <em>data</em>, <em>centers=None</em>, <em>num_neighbors=None</em>, <em>RBF=None</em>, <em>ep=None</em>, <em>normalize=True</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.sensitivity.gradients.calculate_gradients_rbf" title="Permalink to this definition">¶</a></dt>
<dd><p>Approximate gradient vectors at <code class="docutils literal"><span class="pre">num_centers,</span> <span class="pre">centers.shape[0]</span></code> points
in the parameter space for each QoI map using a radial basis function
interpolation method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>samples</strong> (<code class="xref py py-class docutils literal"><span class="pre">np.ndarray</span></code> of shape (num_samples, Lambda_dim)) &#8211; Samples for which the model has been solved.</li>
<li><strong>data</strong> (<code class="xref py py-class docutils literal"><span class="pre">np.ndarray</span></code> of shape (num_samples, Data_dim)) &#8211; QoI values corresponding to each sample.</li>
<li><strong>centers</strong> (<code class="xref py py-class docutils literal"><span class="pre">np.ndarray</span></code> of shape (num_exval, Lambda_dim)) &#8211; Points in <span class="math">\(\Lambda\)</span> at which to approximate gradient
information.</li>
<li><strong>num_neighbors</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; Number of nearest neighbors to use in gradient
approximation. Default value is Lambda_dim + 2.</li>
<li><strong>RBF</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/string.html#module-string" title="(in Python v2.7)"><em>string</em></a>) &#8211; Choice of radial basis function. Default is Gaussian</li>
<li><strong>ep</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; Choice of shape parameter for radial basis function.
Default value is 1.0</li>
<li><strong>normalize</strong> (<em>boolean</em>) &#8211; If normalize is True, normalize each gradient
vector</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><code class="xref py py-class docutils literal"><span class="pre">np.ndarray</span></code> of shape (num_samples, Data_dim, Lambda_dim)</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Tensor representation of the gradient vectors of each
QoI map at each point in centers</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.sensitivity.gradients.pick_cfd_points">
<code class="descclassname">bet.sensitivity.gradients.</code><code class="descname">pick_cfd_points</code><span class="sig-paren">(</span><em>centers</em>, <em>rvec</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.sensitivity.gradients.pick_cfd_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Pick 2*Lambda_dim points, for each center, for centered finite difference
gradient approximation.  The center are not needed for the CFD gradient
approximation, they are returned for consistency with the other methods and
because of the common need to have not just the gradient but also the QoI
value at the centers in adaptive sampling algorithms.The points are returned 
in the order: centers, followed by the cluster around the first center, then 
the cluster around the second center and so on.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>centers</strong> (<code class="xref py py-class docutils literal"><span class="pre">np.ndarray</span></code> of shape (num_centers, Lambda_dim)) &#8211; Points in <span class="math">\(\Lambda\)</span> to cluster points around</li>
<li><strong>rvec</strong> (<code class="xref py py-class docutils literal"><span class="pre">np.ndarray</span></code> of shape (Lambda_dim,)) &#8211; The radius of the stencil, along each axis</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><code class="xref py py-class docutils literal"><span class="pre">np.ndarray</span></code> of shape ((2*Lambda_dim+1)*num_centers,
Lambda_dim)</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Samples for centered finite difference stencil for
each point in centers.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.sensitivity.gradients.pick_ffd_points">
<code class="descclassname">bet.sensitivity.gradients.</code><code class="descname">pick_ffd_points</code><span class="sig-paren">(</span><em>centers</em>, <em>rvec</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.sensitivity.gradients.pick_ffd_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Pick Lambda_dim points, for each centers, for a forward finite
difference gradient approximation.  The points are returned in the order:
centers, followed by the cluster around the first center, then the cluster
around the second center and so on.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>centers</strong> (<code class="xref py py-class docutils literal"><span class="pre">np.ndarray</span></code> of shape (num_centers, Lambda_dim)) &#8211; Points in <span class="math">\(\Lambda\)</span> the place stencil around</li>
<li><strong>rvec</strong> (<code class="xref py py-class docutils literal"><span class="pre">np.ndarray</span></code> of shape (Lambda_dim,)) &#8211; The radius of the stencil, along each axis</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><code class="xref py py-class docutils literal"><span class="pre">np.ndarray</span></code> of shape ((Lambda_dim+1)*num_centers,
Lambda_dim)</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Samples for centered finite difference stencil for
each point in centers.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.sensitivity.gradients.radial_basis_function">
<code class="descclassname">bet.sensitivity.gradients.</code><code class="descname">radial_basis_function</code><span class="sig-paren">(</span><em>r</em>, <em>kernel=None</em>, <em>ep=None</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.sensitivity.gradients.radial_basis_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate a chosen radial basis function.  Allow for the choice of several
radial basis functions to use in
:meth:~bet.sensitivity.gradients.calculate_gradients_rbf</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>r</strong> (<code class="xref py py-class docutils literal"><span class="pre">np.ndarray</span></code>) &#8211; Distances from the reference point</li>
<li><strong>kernel</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/string.html#module-string" title="(in Python v2.7)"><em>string</em></a>) &#8211; Choice of radial basis funtion. Default is C4Matern</li>
<li><strong>ep</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; Shape parameter for the radial basis function.
Default is 1.0</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><code class="xref py py-class docutils literal"><span class="pre">np.ndarray</span></code> of shape (r.shape)</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Radial basis function evaluated for each element of r</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.sensitivity.gradients.radial_basis_function_dxi">
<code class="descclassname">bet.sensitivity.gradients.</code><code class="descname">radial_basis_function_dxi</code><span class="sig-paren">(</span><em>r</em>, <em>xi</em>, <em>kernel=None</em>, <em>ep=None</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.sensitivity.gradients.radial_basis_function_dxi" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate a partial derivative of a chosen radial basis function.  Allow for
the choice of several radial basis functions to use in the
:meth:~bet.sensitivity.gradients.calculate_gradients_rbf.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>r</strong> (<code class="xref py py-class docutils literal"><span class="pre">np.ndarray</span></code>) &#8211; Distances from the reference point</li>
<li><strong>xi</strong> (<code class="xref py py-class docutils literal"><span class="pre">np.ndarray</span></code>) &#8211; Distances from the reference point in dimension i</li>
<li><strong>kernel</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/string.html#module-string" title="(in Python v2.7)"><em>string</em></a>) &#8211; Choice of radial basis funtion. Default is C4Matern</li>
<li><strong>ep</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; Shape parameter for the radial basis function.
Default is 1.0</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><code class="xref py py-class docutils literal"><span class="pre">np.ndarray</span></code> of shape (r.shape)</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Radial basis function evaluated for each element of r</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.sensitivity.gradients.sample_l1_ball">
<code class="descclassname">bet.sensitivity.gradients.</code><code class="descname">sample_l1_ball</code><span class="sig-paren">(</span><em>centers</em>, <em>num_close</em>, <em>rvec</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.sensitivity.gradients.sample_l1_ball" title="Permalink to this definition">¶</a></dt>
<dd><p>Uniformly sample the l1-ball (defined by 2^dim simplices).  Then scale
each dimension according to rvec and translate the center to centers.
Do this for each point in centers.  <em>This method currently allows
samples to be placed outside of lam_domain.  Please place your
centers accordingly.</em></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>centers</strong> (<code class="xref py py-class docutils literal"><span class="pre">np.ndarray</span></code> of shape (num_centers, Ldim)) &#8211; Points in <span class="math">\(\Lambda\)</span> to cluster samples around</li>
<li><strong>num_close</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; Number of samples in each l1 ball</li>
<li><strong>rvec</strong> (<code class="xref py py-class docutils literal"><span class="pre">np.ndarray</span></code> of shape (Lambda_dim)) &#8211; The radius of the l1 ball, along each axis</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><code class="xref py py-class docutils literal"><span class="pre">np.ndarray</span></code> of shape ((num_close+1)*num_centers, Lambda_dim)</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Uniform random samples from an l1 ball around each center</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="bet.sensitivity.gradients.sample_linf_ball">
<code class="descclassname">bet.sensitivity.gradients.</code><code class="descname">sample_linf_ball</code><span class="sig-paren">(</span><em>centers</em>, <em>num_close</em>, <em>rvec</em>, <em>lam_domain=None</em><span class="sig-paren">)</span><a class="headerlink" href="#bet.sensitivity.gradients.sample_linf_ball" title="Permalink to this definition">¶</a></dt>
<dd><p>Pick num_close points in a the l-infinity ball of length 2*rvec around a
point in <span class="math">\(\Lambda\)</span>, do this for each point in centers.  If this box
extends outside of <span class="math">\(\Lambda\)</span>, we sample the intersection.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>centers</strong> (<code class="xref py py-class docutils literal"><span class="pre">np.ndarray</span></code> of shape (num_centers, Lambda_dim)) &#8211; Points in <span class="math">\(\Lambda\)</span> to cluster points around</li>
<li><strong>num_close</strong> (<a class="reference external" href="https://docs.python.org/2.7/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; Number of points in each cluster</li>
<li><strong>rvec</strong> (<code class="xref py py-class docutils literal"><span class="pre">np.ndarray</span></code> of shape (Lambda_dim,)) &#8211; Each side of the box will have length 2*rvec[i]</li>
<li><strong>lam_domain</strong> (<code class="xref py py-class docutils literal"><span class="pre">np.ndarray</span></code> of shape (Lambda_dim, 2)) &#8211; The domain of the parameter space</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><code class="xref py py-class docutils literal"><span class="pre">np.ndarray</span></code> of shape ((num_close+1)*num_centers, Lambda_dim)</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Centers and clusters of samples near each center</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-bet.sensitivity">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-bet.sensitivity" title="Permalink to this headline">¶</a></h2>
<p>This subpackage provides methods for approximating gradients of
QoI maps and choosing optimal QoIs to use in the inverse problem.</p>
<ul>
<li><dl class="first docutils">
<dt><a class="reference internal" href="#module-bet.sensitivity.gradients" title="bet.sensitivity.gradients"><code class="xref py py-mod docutils literal"><span class="pre">gradients</span></code></a> provides methods for approximating</dt>
<dd><p class="first last">gradients of QoI maps.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><a class="reference internal" href="#module-bet.sensitivity.chooseQoIs" title="bet.sensitivity.chooseQoIs"><code class="xref py py-mod docutils literal"><span class="pre">chooseQoIs</span></code></a> provides methods for choosing optimal</dt>
<dd><p class="first last">QoIs to use in the inverse problem.</p>
</dd>
</dl>
</li>
</ul>
</div>
</div>


          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="todo_list.html" class="btn btn-neutral float-right" title="Todo List">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="bet.sampling.html" class="btn btn-neutral" title="bet.sampling package"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2014, The BET Development Team (Lindley Graham, Steven Mattis, Troy Butler).
      Last updated on Dec 03, 2015.
    </p>
  </div>

  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
  
</footer>
        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.0.2',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>